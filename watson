#!/usr/bin/perl
# watson - inline issue manager
# nhmood @ [goosecode labs] | 2012
# Copyright (c) 2012-2013 goosecode labs
# This content is licensed under the MIT License
# See the file LICENSE for copying permission


# [todo] - add priority listing for tags and todo
# [todo] - generate .html file with report
# [todo] - add text editor/jump to code for each item in .html report
# [todo] - if x is placed in todo [!] then move it to separate file
# [todo] - store in separate file or parse every time? (thinking parse)
# [todo] - tell when directory changes with some header
# [todo] - change @IGNOREDIR to hash instead of array for efficiency
# [todo] - only allow user to check executing users files (setuid exploit)
# [todo] - wrap printed lines around 80 characters
# [todo] - command line option to remove remote repos
# [todo] - replace json parser with just grep? need to get status if failed
# [todo] - add ability to update issue if same title but different md5
# [todo] - implement local only reporting (make it default?)
# [todo] - progress bar for obtaining github/bitbucket issue list
# [todo] - local should be default, must use -r or remote flag to post and check?
#		 - maybe have it check against background unless -local is passed
#		 - but dont post unless --post is used (make it faster?)
# [todo] - add status indicator for remote requests
#		 - we know # of requests and which we are on, can do it that way
# [todo] - change github issue checks to -d instead of issue?key=val
# [todo] - add remote / local options and necessary logic
# [todo] - replace open/closed issue var with just all and closed?

###########################################################
# Global parameters
###########################################################

use strict;
use feature qw/say/;  # implies dependency on perl 5.10
use warnings;

# For color print outs
use Term::ANSIColor qw(:constants);

# Route Ctrl-C to cExit to clean up results
$SIG{'INT'} = \&cExit;

# For debugging (print data structures)
use Data::Dumper;

# For MD5 Sum (issue posting check)
use Digest::MD5 qw(md5_hex);

# App Config
my $DEBUG = $ENV{WATSON_DEBUG};
my $RCNAME = ".watsonrc";		# Change config file name
my $TMPOUT = ".watsonresults";	# Change tmp file name

# Global variables
my @DIRS;
my @FILES;
my @TAGS;
my %TAGS;
my @IGNORE;
my @STRUCTURE;
my $REMOTESETUP = 0;
my $GITHUB_VALID = 0;
my $GITHUB_API;
my $GITHUB_REPO;
my $GITHUB_OPEN_ISSUES;
my $GITHUB_CLOSED_ISSUES;
my $BITBUCKET_VALID = 0;
my $BITBUCKET_API;
my $BITBUCKET_PW;
my $BITBUCKET_REPO;
my $BITBUCKET_OPEN_ISSUES;
my $BITBUCKET_CLOSED_ISSUES;
my $MAX_DEPTH = 0;
my $IGNORE_RC_DIRS = 0;
my $IGNORE_RC_FILES = 0;
my $IGNORE_RC_TAGS = 0;
my $IGNORE_RC_IGNORE = 0;
my $HASLESS = 0;
my $HASCURL = 0;
my $LESSOUT;


use constant GITHUB => 0;
use constant BITBUCKET => 1;


#----------------------------------------------------------
###########################################################
# Main Program
###########################################################
#----------------------------------------------------------

checkLess();
checkcURL();
printHeader();
parseCommandLine();
checkConfig();
parseConfig();
startScan();
createReport();


#----------------------------------------------------------
###########################################################
# Functions
###########################################################
#----------------------------------------------------------


###########################################################
# Header Print
###########################################################

# Print watson header
sub printHeader {
	wprint(BOLD "------------------------------\n");
	wprint(BOLD "watson", RESET);
	wprint(" - ");
	wprint(BOLD YELLOW "inline issue manager\n\n", RESET);
	my $pwd = `pwd`;
	wprint("Run in: $pwd");
	my $time = localtime;
	wprint("Run @ $time\n");
	wprint(BOLD "------------------------------\n\n");
	return 1;
}


###########################################################
# Help Print
###########################################################

# Print watson help
sub printHelp {
	print BOLD, <<'END_HELP', RESET;
Usage: watson [OPTION]...
Running watson with no arguments will parse with settings in RC file
If no RC file exists, default RC file will be created

   -d, --dirs			list of directories to search in
   -f, --files			list of files to search in
   -h, --help			say help
   -i, --ignore			list of files, directories, or types to ignore
   -p, --parse-depth		depth to recursively parse directories
   -r, --remote			list / create tokens for Bitbucket/Github
   -t, --tags			list of tags to search for
   -v, --version		say watson version and info

Any number of files, tags, dirs, and ignores can be listed after flag
Ignored files should be space separated
To use *.filetype identifier, encapsulate in \"\" to avoid shell substitutions


Report bugs to: watson\@goosecode.com
watson home page: <http://goosecode.com/projects/watson>
[goosecode] labs | 2012-2013";
END_HELP

	return 1;
}


###########################################################
# Help Print
###########################################################

# Print watson help
sub printVersion {
	print <<'END_VERSION';
watson v1.3
Copyright (c) 2012-2013 goosecode labs
Licensed under MIT, see LICENSE for details

Written by nhmood, see <http://goosecode.com/projects/watson>
END_VERSION

	return 1;
}


###########################################################
# Clean Exit
###########################################################

# Clean exit function that removes temp files
sub cExit {
	my ($exit_status) = @_;

	unlink $TMPOUT or warn "Could not remove $TMPOUT: $!";

	# If exit status is INT(terupt), set to 1 and print newline
	if ($exit_status eq "INT"){
		$exit_status = 1;
		print "\n";
	}
	exit $exit_status;
}


###########################################################
# Debug Print
###########################################################

# Debug print statements that are only enabled
# when debug flag is set (top of file)
sub debugPrint {
	print @_ if $DEBUG;
}


###########################################################
# Output Print
###########################################################

# If system has less, dump all output to .tmp file and use less
# If no less, just print straight to stdout
sub wprint {
	if ($HASLESS){
		print $LESSOUT @_;
		return 1;
	}
	else {
		print @_;
		return 0;
	}
}


###########################################################
# Unix less Checker
###########################################################

# Check to see if system has less
# If so, set flag and open tmp file
sub checkLess {
	return $HASLESS if defined $HASLESS;
	$HASLESS //= !system("which less > /dev/null 2>&1") or return 0;
	open $LESSOUT, "+>", $TMPOUT;
	return 1;
}


###########################################################
# cURL Checker
###########################################################

# Check to see if system has cURL
# If so, set flag
sub checkcURL {
	return $HASCURL //= !system("which curl > /dev/null 2>&1");
}


###########################################################
# Directory checker
###########################################################

# checkDir - checks if directory can be opened
# Different from just using -d, checks if able to OPEN
sub checkDir {
	my ($dir) = @_;

	# Error check for input
	unless (length $dir) {
		wprint("No directories specified.\n");
		return 0;
	}

	# Check if directory can be opened
	opendir my $tDIR, $dir or do {
		wprint(qq{Cannot open dir "$dir": $!\n});
		return 0;
	};

	closedir $tDIR;
	debugPrint(qq{"$dir" exists and opened successfully.\n});
	return 1;
}


###########################################################
# File checker
###########################################################

# checkFile - checks if file can be opened
# Different from just using -f, checks if able to OPEN
sub checkFile {
	my ($file) = @_;

	# Error check for input
	unless (length $file) {
		wprint("No file specified.\n");
		return 0;
	}

	# Check if file can be opened
	open my $tFILE, $file or do {
		wprint(qq{Could not open "$file": $!\n});
		return 0;
	};

	close $tFILE;
	debugPrint(qq{"$file"" exists and opened successfully.\n});
	return 1;
}


###########################################################
# Config file check
###########################################################

# Check for config file in same dir as watson
# If it doesn't exist, create the default one
sub checkConfig {
	# Should have individual .rc for each dir that watson is in
	# This allows you to keep different preferences for different projects

	# Check for rc
	debugPrint("[Checking for $RCNAME]\n");
	if (-e $RCNAME) {
		debugPrint("$RCNAME found\n\n");
		return 1;
	}
	else {
		debugPrint("$RCNAME not found!\n");
		debugPrint("Creating default $RCNAME\n");

		# Create default rc
		createRC($RCNAME);
		return 0;
	}
}


###########################################################
# Default config file writer
###########################################################

# Create default RC file with some generic settings
sub createRC {
	my ($file_name) = @_;
	open my $file, "+>>", $file_name or die qq{Can't open "$file_name": $!};

# [fixme] - Figure out a way to indent this?
my $rcdefault = <<'EOF';
# watson rc
# watson - inline issue manager
# [goosecode] labs / 2012


# Directories
[dirs]
./


# Tags
[tags]
fix
review
todo


# Ignores
[ignore]
.git
.swp
EOF

	debugPrint($rcdefault);
	# Print default rc above to specified file
	my $success = print $file $rcdefault;
	close($file);
	return $success;
}


###########################################################
# Command line parser
###########################################################

# Parse command line arguments
sub parseCommandLine {
	debugPrint("[Checking CL args]\n");
	debugPrint("Total args: ", $#ARGV + 1, "\n");

	my %long_opts = (
		"-d" => "--dirs",
		"-f" => "--files",
		"-h" => "--help",
		"-v" => "--version",
		"-t" => "--tags",
		"-p" => "--parse-depth",
		"-i" => "--ignore",
		"-r" => "--remote",
		"-u" => "--update"
	);
	my %opts;
	@opts{%long_opts} = ();

	my $slurp_items = sub {
		my ($cb) = @_;
		my $count = 0;

		# Keep checking following options until another flag or end
		while (@ARGV) {
			if (exists $opts{$ARGV[0]}) {
				debugPrint("Found a flag: $ARGV[0]\n");
				last;
			}

			my $item = shift @ARGV;
			$cb->($item);
		}
	};

	my %flag_actions = (
		'--help' => sub {
			debugPrint("Help flag passed\n");
			printHelp();
			cExit(0);
		},
		'--version' => sub {
			debugPrint("Version flag passed\n");
			printVersion();
			cExit(0);
		},
		'--parse-depth' => sub {
			debugPrint("Parse Depth flag passed\n");
			# Check to make sure next param is a valid number (non-negative)

			unless (@ARGV) {
				wprint(box(BOLD RED "x"), "--parse-depth requires a numeric argument\n");
			}

			my $depth = shift @ARGV;

			if ($depth =~ /[^0-9]/) {
				wprint(box(BOLD MAGENTA "!"));
				wprint("--> ", RESET);
				wprint("Invalid parse depth passed\n");
				return;
			}

			$MAX_DEPTH = $depth;
			debugPrint("Valid parse depth: $MAX_DEPTH\n");
		},
		'--remote' => sub {
			debugPrint("Remote Flag passed\n");

			# When generating OAuth Token for github/bitbucket
			# no other params should be passed
			if (@ARGV > 1){
				debugPrint("Not the only flag, exiting\n");
				print box(BOLD RED "x");
				print "Please run remote flag alone to generate GitHub/Bitbucket OAuth token\n";
				print "      See help for more details\n";
				cExit(1);
			}

			# Can only do this if we have cURL on the system
			unless ($HASCURL) {
				print box(BOLD RED "x");
				print "It looks like you don't have cURL\n";
				print "      We currently only support remote issues if you have cURL\n";
				print "      Make sure cURL is installed and in your PATH\n";
				cExit(1);
			}

			my $service = lc shift @ARGV;

			if ($service eq "bitbucket") {
				bitbucketSetup();
			}
			elsif ($service eq "github") {
				githubSetup();
			}
			elsif ($service eq "") {
				parseConfig() if checkConfig();

				if ($BITBUCKET_API eq "" && $GITHUB_API eq "") {
					print box(BOLD RED "x");
					print BOLD "No remotes currently exist\n", RESET;
					print BOLD "      Pass github or bitbucket to watson -r to add\n", RESET;
					print "      That's all we support right now :(\n";
					print "      See help for more details\n";
					cExit(1);
				}

				if ($BITBUCKET_API ne "") {
					print box(BOLD GREEN "Bitbucket"), "\n";
					print BOLD "   Bitbucket User :", RESET, " $BITBUCKET_API\n";
					print BOLD "   Bitbucket Repo :", RESET, " $BITBUCKET_REPO\n";
					print "\n";
				}

				if ($GITHUB_API ne "") {
					print BOLD "[ ", RESET;
					print BOLD GREEN "GitHub ", RESET;
					print BOLD "]\n", RESET;
					print BOLD "   GitHub Key  :", RESET, " $GITHUB_API\n";
					print BOLD "   GitHub Repo :", RESET, " $GITHUB_REPO\n";
					print "\n";
				}

				cExit(1);
			}
			else {
				print box(BOLD RED "x");
				print BOLD "Incorrect argument\n", RESET;
				print "      Please specify either github or bitbucket to setup remote\n";
				print "      Or pass without argument to see current remotes\n";
				print "      See help for more details\n";
				cExit(1);
			}
		},
		'--dirs' => sub {
			debugPrint("Dir flag passed\n");
			$slurp_items->(sub {
				my ($dir) = @_;
				debugPrint("Dir Index: $dir\n");

				if (checkDir($dir)) {
					debugPrint("dirflag: {$dir} valid directory, added from CL.\n");

					# If we ever get into this, means CL passed
					# Set RC ignore so we don't look at rc
					debugPrint("Ignoring RC Files/Dirs\n\n");
					$IGNORE_RC_DIRS = 1;

					# Remove trailing slashes
					$dir =~ s{/+\z}{};
					push @DIRS, $dir;
				}
			});
		},
		'--files' => sub {
			debugPrint("File flag passed\n");
			$slurp_items->(sub {
				my ($file) = @_;
				debugPrint("File Index: $file\n");

				if (checkFile($file)) {
					debugPrint("fileflag: {$file} valid file, added from CL.\n");

					# If we ever get into this, means CL passed
					# Set RC ignore so we don't look at rc
					debugPrint("Ignoring RC Files/Dirs\n\n");
					$IGNORE_RC_FILES = 1;

					push @FILES, $file;
					}
			});
		},
		'--tags' => sub {
			debugPrint("Tag flag passed\n");
			$slurp_items->(sub {
				my ($tag) = @_;
				debugPrint("Tag Index: $tag\n");
				debugPrint("tagflag: {$tag} added from CL.\n");

				# If we ever get into this, means CL passed
				# Set RC ignore so we don't look at rc
				debugPrint("Ignoring RC tags\n\n");
				$IGNORE_RC_TAGS = 1;

				push @TAGS, $tag;
			});
		},
		'--ignore' => sub {
			debugPrint("Tag flag passed\n");
			$slurp_items->(sub {
				my ($ignoreflag) = @_;
				debugPrint("Ignore Index: $ignoreflag\n");
				debugPrint("ignoreflag: {$ignoreflag} added from CL.\n");

				# If we ever get into this, means CL passed
				# Set RC ignore so we don't look at rc
				debugPrint("Ignoring RC ignore\n\n");
				$IGNORE_RC_IGNORE = 1;

				push @IGNORE, $ignoreflag;
			});
		},
	);
	for my $key (keys %long_opts) {
		$flag_actions{$key} = $flag_actions{$long_opts{$key}};
		exists $flag_actions{$key}
			or warn "The option $long_opts{$key} is not implemented";
	}

	unless (@ARGV) {
		debugPrint("No command line arguments passed.\n\n");
		return;
	}

	while (@ARGV) {
		my $item = shift @ARGV;
		debugPrint("Main Item: $item\n");

		if (my $action = $flag_actions{$item}) {
			$action->();
		}
		else {
			die qq{Can't understand command line argument "$item"};
		}
	}
	return 1;
}


###########################################################
# Config file parser
###########################################################

# Go through config file and determine dirs, tags, and ignores to use
sub parseConfig {
	# Parse rc
	debugPrint("Parsing $RCNAME\n");

	open my $rc, "<", $RCNAME or die qq{Can't open "$RCNAME": $!};

	# Add . and .. and .git to ignorelist
	push @IGNORE, ".", "..", "*.swp", ".watsonrc", $TMPOUT;


	my %sections = (
		# If @DIRS or @FILES wasn't populated by CL args, populate from rc
		dirs => sub {
			my ($line) = @_;
			if ($IGNORE_RC_DIRS || $IGNORE_RC_FILES) {
				debugPrint("Directories set from command line, ignoring rc [dirs]!\n");
				return;
			}
			# Regex for dirs, then push to @DIRS
			$line =~ m{\A\s* ((?:\.?/?\w?+/?)+) \s*\z}x
				or die qq{The line "$line" in a "dirs" section did not contain a valid path};
			($line = $1) =~ s{/+\z}{};
			debugPrint("dirs: $line added from rc. \n");
			push @DIRS, $line;
		},
		# If @TAGS wasn't populated by CL args, populate from rc
		tags => sub {
			my ($line) = @_;
			if ($IGNORE_RC_TAGS) {
				debugPrint("Directories set from command line, ignoring rc [dirs]!\n");
				return;
			}
			# Regex for tags, then push to @TAGS
			$line =~ /^\A\s* (\w+(?: \| [0-9])?) \s*\z/x
				or die qq{The line "$line" in a "tags" section did not contain a valid tag};
			my $tag = $1;
			debugPrint("tags: $tag added from rc.\n");
			push @TAGS, $tag;
		},
		# If @IGNORE wasn't populated by CL args, populate from rc
		ignore => sub {
			my ($line) = @_;
			if ($IGNORE_RC_IGNORE) {
				debugPrint("Directories set from command line, ignoring rc [dirs]!\n");
				return;
			}
			# Regex for dirs to ignore, then push to @IGNOREDIR

			$line =~ m{\A\s* ((/?\w+/?)+) \s*\z}x
				or die qq{The line "$line" is a "ignore" section did not contain a valid path};
			(my $path = $1) =~ s{(/)+\z}{};
			debugPrint("ignore: $path added from rc.\n");
			push @IGNORE, $path;
		},
		github => sub {
			my ($line) = @_;
			# No need for regex on API key
			debugPrint("GitHub API: $line\n");
			$GITHUB_API = $line;
		},
		bitbucket => sub {
			my ($line) = @_;
			# No need for regex on API key
			debugPrint("Bitbucket API: $line\n");
			$BITBUCKET_API = $line;
		},
		githubrepo => sub {
			my ($line) = @_;
			# No need for regex on repo
			debugPrint("GitHub Repo: $line\n");
			$GITHUB_REPO = $line;

			# If setting up remote, don't ask for password / do any remote stuff
			# Won't need this when OAuth implemented but it does optimize the code...

			# Get list of issues, also checks if API key is valid
			getGithubIssues() unless $REMOTESETUP
		},
		bitbucketrepo => sub {
			my ($line) = @_;
			# No need for regex on repo
			debugPrint("Bitbucket Repo: $line\n");
			$BITBUCKET_REPO = $line;

			# If setting up remote, don't ask for password / do any remote stuff
			# Won't need this when OAuth implemented but it does optimize the code...
			# Get list of issues, also checks if API key is valid
			getBitbucketIssues() unless $REMOTESETUP;
		},
	);

	# Read rc line by line
	my $section = "";
	while (my $line = <$rc>){
	    debugPrint($line);
		chomp $line;

		# Ignore full line comments
		next if $line =~ /^#/ or $line !~ /\S/;

		# Regex to find [section], store into $section and continue to the
		# next line until a new section
		if ($line =~ /^\[(\w+)\]/){
			$section = $1;
			next;
		}

		my $action = $sections{$section}
			or die qq{Unknown section "$section"};
		$action->($line);
	}

	debugPrint("\n\n\n");
	close $rc;
	return 1;
}


###########################################################
# File/Folder Parser Wrapper
###########################################################

# Start going through all files and subdirs of specified folder
sub startScan{

	# If files passed to command line, push those to structure
	# Have to populate structure this way to print properly
	if ($IGNORE_RC_FILES){
		# For each file obtained from CL (if any) parse file
		# Create proper structure for files so we can push to @STRUCTURE
		push @STRUCTURE, {
			files => [ map { parseFile($_) } @FILES ],
		};
	}

	# For each directory obtained from rc or CL, look for files in them
	# This will always be valid, not condition like files above
	for my $dir (@DIRS){
		push @STRUCTURE, parseDirs($dir);
	}

	wprint("\n");
	return 1;
}


###########################################################
# Directory Parser
###########################################################

# Look through directory for files to parse
sub parseDirs {
	my ($dir, $depth) = @_;
	$depth //= 1;
	return if $MAX_DEPTH and $depth > $MAX_DEPTH;
	debugPrint("parseDirs: |$dir| at depth $depth\n");
	return unless checkDir($dir); # Error check for input

	my @pdirs;		# subdirectories found
	my @pfiles;		# files found

	# Loop through all entries in directory
	debugPrint(qq{Looping through all files/folders in "$dir"\n});

	# Open dir and get list of all files
	opendir my $wd, $dir or die qq{Can't open directory "$dir": $!};
	ENTRY: for my $entry (sort grep !/\.\.?/, readdir $wd) {
		# Combine dir and entry to make full path
		my $path = "$dir/$entry";

		debugPrint("path: |$path|\n");

		# Make sure it isn't part of ignored list
		# If it is, set to "", won't pass dir/file check
		# [reviewme] - Should we warn users when file is ignored on stdout?
		for my $ignore (@IGNORE){
			# Check for any *.type in ignore list (list .swp)
			# Regex to see if extension is .type, ignore if so
			($ignore) = map qr/\A$_\z/, join '.*', map quotemeta, split /[*]/, $ignore
				unless ref $ignore;
			if ($entry =~ /$ignore/) {
				debugPrint("|$path| is on the ignore list, skipping\n");
				next ENTRY;
			}
		}

		# Check if entry is a file, if so parse
		if (-f $path) {
			debugPrint("|$path| is a file!\n");
			push @pfiles, parseFile($path);
		}
		# Check if entry is dir, if so parse
		elsif (-d $path) {
			debugPrint("|$path| is a dir!\n");
			push @pdirs, parseDirs($path, $depth + 1);
		}

		# Add directory to ignore list so it isn't repeated again
		push @IGNORE, $path;
	}

	closedir $wd;
	# Create has to hold all parsed files and folders
	return {
		files => \@pfiles,
		dirs => \@pdirs,
	};
}


###########################################################
# File Parser
###########################################################

sub parseFile {
	# [fixme] - need a better check for valid files (when using @_)
	my ($file) = @_;
	debugPrint("parseFile: |$file|\n");

	# Error check for input
	if (!checkFile($file)){
		return 0;
	}

	# Get filetype and set corresponding comment type
	my $comment = getComment($file);
	if (!$comment){
		print(BOLD "[ ", RESET);
		print(BOLD MAGENTA "! ", RESET);
		print(BOLD "] ", RESET);
		print("--> ", RESET);
		print("Couldn't determine filetype for $file, using # as comment\n", RESET);
		$comment = "#";
	}

	# Open file and seek to beginning
	open(my $wf, "<", $file);
	seek($wf, 0, 0);

	# Initialize tag arrays so they are globally avaliable
	foreach my $tag (@TAGS){
	    debugPrint("Creating array named $tag \n");
		$TAGS{$tag} = [];
	}

	# Read source file line by line
	my $linecount = 0;
	while (my $line = <$wf>){
	    $linecount++;
	    # Find any comment line with [tag] - text (any comb of space and #)
	    if ($line =~ /\s*($comment)+\s*\[(\S+)\]\s*-\s*(.+)/) {
			my $fissue = $3;
			my $ftag = $2;
			debugPrint("Issue found!\n");
			debugPrint("Tag: $ftag\n");
			debugPrint("Issue: $fissue\n");

			foreach my $tag (@TAGS) {
		    	if ($ftag eq $tag) {
					# Create hash for each issue found (for each tag)
					my $issue = {};
					$issue->{linenumber} = $linecount;
					$issue->{comment} = $fissue;

					# Create hash for specific issue
					my $digest = md5_hex($issue->{tag}, $issue->{file}, $issue->{comment});
					debugPrint("$digest\n");
					$issue->{md5} = $digest;

					push(@{$TAGS{$tag}}, $issue);

					# If Github valid, append file and tag, pass $issue to poster function
					if ($GITHUB_VALID){
						$issue->{file} = $file;
						$issue->{tag} = $tag;
						postGithub($issue);
					}

					# If Bitbucket valid, append file and tag, pass $issue to poster function
					if ($BITBUCKET_VALID){
						$issue->{file} = $file;
						$issue->{tag} = $tag;
						postBitbucket($issue);
					}

		    	}
			}
	    }
	}

	#[fixme] - change name to issueList
	my $issueList = {};
	$issueList->{filename} = "$file";

	# Toss on each tag found into the file's hash
	foreach my $tag (@TAGS){
	       	$issueList->{$tag} = [@{delete $TAGS{$tag}}];
		debugPrint(Dumper($issueList));
	}
	return $issueList;
}


###########################################################
# Comment setter
###########################################################

# Determine comment type from file extension
sub getComment {
	my ($file) = @_;
	debugPrint("Getting comment type\n");

	# Grab the ending extension (.something)
	# Check to see whether it is recognized and set comment type
	# If unrecognized, try to grab next .something extension
	# This is to account for file.cpp.1 or file.cpp.bak, ect

	while ( (my $ext) = $file =~ m/(\.(\w+))$/){
		# Regex for last extension
		debugPrint("Extension: $ext\n");

		# Determine file type
		# Not using switch/case for compatibility...

		# C / C++
		# [todo] - add /* style comment
		if ( $ext eq ".cpp" || $ext eq ".cc" ||  $ext eq ".c" || $ext eq ".h"){
			debugPrint("Comment type is: //\n");
			return "//";
		}
		# Bash / Ruby / Perl
		elsif ( $ext eq ".sh" || $ext eq ".rb" || $ext eq ".pl"){
			debugPrint("Comment type is: #\n");
			return "#";
		}
		# Can't recognize extension, keep looping
		else {
			$file =~ s/(\.(\w+))$//;
			debugPrint("Didn't recognize, new file: $file\n");
		}
	}

	# Didn't find any match, return error (and just use #)
	return 0;
}


###########################################################
# Result Printer Wrapper
###########################################################

# Format the parsed file data and output it nicely
sub createReport {
	# Display output for each file parsed
	foreach my $entry (@STRUCTURE){
		printResults($entry);
	}

	if ($HASLESS){
		system("less -R $TMPOUT");
		close($LESSOUT);
		system("rm $TMPOUT > /dev/null 2>&1");
	}
	return 1;
}


###########################################################
# Individual Result Printer
###########################################################

# Print results from parsing all pretty and stuff
sub printResults {
	my ($entry) = @_;
	# Go through and print info for all files first
	for (my $i = 0; $i < scalar( @{$entry->{files}}); $i++){

		# [fixme] - Same foreach performed below, combine somehow?

		# Go through and see if there are any issues with given file
		# Sets print color and whether to continue to print
		my $issueflag = 0;
		foreach my $tag (@TAGS){
			if (scalar( @{$entry->{files}[$i]->{$tag}})){
				$issueflag++;
			}
		}

		if ($issueflag){
			wprint("\n");
			wprint(BOLD "[ ", RESET);
			wprint(BOLD RED "x ", RESET);
			wprint(BOLD "] ", RESET);
			wprint(UNDERLINE BOLD RED "$entry->{files}[$i]->{filename}", RESET);
		}
		else {
			wprint(BOLD "[ ", RESET);
			wprint(BOLD GREEN "o ", RESET);
			wprint(BOLD "] ", RESET);
			wprint(UNDERLINE BOLD GREEN "$entry->{files}[$i]->{filename}", RESET);
		}

		wprint("\n");

		# If there are no issues, don't print anything (go to next file)
		# Else, continue on and print the issues
		($issueflag > 0) ? (1) : (next);

		# Cycle through all tags and print issues for each
		foreach my $tag (@TAGS){

			# If no issues in tag, don't print
			if (!scalar( @{$entry->{files}[$i]->{$tag}})){
				next;
			}

			# Print tag, line #, and issue
			wprint(BOLD  "\[ ", RESET);
			wprint(BOLD BLUE "$tag", RESET);
			wprint(BOLD  " \]\n", RESET);



			for (my $j = 0; $j < scalar( @{$entry->{files}[$i]->{$tag}}); $j++){
				wprint(WHITE "  line $entry->{files}[$i]->{$tag}[$j]->{linenumber} - ", RESET);
				wprint(BOLD "$entry->{files}[$i]->{$tag}[$j]->{comment} ", RESET);

				# If valid API key
				# Check if issue has been closed on Github or Bitbucket, set to resolved
				if ( ($GITHUB_VALID) ){
					if ( ($GITHUB_CLOSED_ISSUES =~ m/$entry->{files}[$i]->{$tag}[$j]->{md5}/) ) {
						wprint(BOLD "\[", RESET);
						wprint(BOLD GREEN "Resolved on GitHub", RESET);
						wprint(BOLD "\]");
					}
				}


				if ( ($BITBUCKET_VALID) ){
					if ( ($BITBUCKET_CLOSED_ISSUES =~ m/$entry->{files}[$i]->{$tag}[$j]->{md5}/) ){
						wprint(BOLD "\[", RESET);
						wprint(BOLD GREEN "Resolved on Bitbucket", RESET);
						wprint(BOLD "\]");
					}
				}

				wprint("\n");
			}
			wprint("\n");
		}
	}

	for (my $i = 0; $i < scalar( @{$entry->{dirs}}); $i++){
		printResults($entry->{dirs}[$i]);
	}
	return 1;
}


###########################################################
# JSON Parser
###########################################################

# Parse JSON response from github/bitbucket issue requests
sub parseJSON {
	my ($json) = @_;

	debugPrint("JSON Parser");

	# Clean up text, separate with : delimiter
	# Throw data into hash
	my $js = {};
	my @lines = split /\n/, $json;
	foreach my $line (@lines){
		my $ind = index($line, ":");
		if ($ind != -1){
			my $field = substr($line, 0, $ind);
			my $value = substr($line, $ind + 1);
			if ($value ne "{" || $value ne "["){
				# Remove trailing spaces, }, ], ,s and all ""
				$field =~ s/^(\s+)}?]?//g;
				$field =~ s/\"?,?//g;

				$value =~ s/^(\s+)\{?\[?//g;
				$value =~ s/\"?,?//g;

				debugPrint("field: $field\n");
				debugPrint("value: $value\n");
				$js->{$field} = $value;
			}
		}
	}
	return $js;
}


###########################################################
# GitHub Setup
###########################################################

# Obtain API key for either Github
sub githubSetup {
	# JSON Response var
	my $js;

	# Set remote setup to one so password isn't asked for in Bitbucket parseConfig section
	# Crappy fix, won't need this when OAuth is implemented for Bitbucket
	$REMOTESETUP = 1;

	# [fixme] - Same code as header just without wprint, make modular
	print(BOLD "------------------------------\n");
	print(BOLD "watson", RESET);
	print(" - ");
	print(BOLD YELLOW "inline issue manager\n", RESET);
	print(BOLD "------------------------------\n\n");

	# [fixme] - Make modular status printer?
	print BOLD "[ ", RESET;
	print BOLD GREEN "+ ", RESET;
	print BOLD "] ", RESET;
	print BOLD "Obtaining OAuth Token for GitHub...\n", RESET;

	# Parse config to make sure no previous API exists
	parseConfig() if checkConfig();

	if ( ($GITHUB_API  ne "") ||
		 ($GITHUB_REPO ne "") ){
		print BOLD "[ ", RESET;
		print BOLD RED "! ", RESET;
		print BOLD "] ", RESET;
		print BOLD "Previous GitHub API + Repo is in RC, are you sure you want to overwrite?\n", RESET;
		print "      (Y)es/(N)o: ";

		my $overwrite = <STDIN>;
		chomp $overwrite;
		print "\n";

		if ($overwrite eq "" || uc($overwrite) eq "NO" ||
			uc($overwrite) eq "N"){
			print BOLD "[ ", RESET;
			print BOLD RED "x ", RESET;
			print BOLD "] ", RESET;
			print BOLD "Not overwriting current GitHub API + repo info\n", RESET;
			cExit(1);
		}
	}


	print BOLD "[ ", RESET;
	print BOLD YELLOW "! ", RESET;
	print BOLD "] ", RESET;
	print BOLD "Access to your GitHub account required to make/update issues\n", RESET;

	print "      See help or README for more details on GitHub/Bitbucket access\n\n";

	# Get username, clear newlines surrounding text
	# If blank, give error
	print BOLD "Username: ", RESET;
	my $username = <STDIN>;
	chomp $username;
	if ($username eq ""){
		print BOLD "[ ", RESET;
		print BOLD RED "x ", RESET;
		print BOLD "] ", RESET;
		print BOLD "Input blank. Please enter your username!\n", RESET;
		cExit(1);
	}

	# cURL to get OAuth Token, returns JSON

	$js = do {
		my $call = "curl -s -i " .
				"https://api.github.com/authorizations " .
				"-u $username " .
				"-d '{\"scopes\": [\"repo\"], " .
					"\"note\": \"watson\", " .
					"\"note_url\" : \"http://watson.goosecode.com\"}' ";

		print BOLD;
		my $response = `$call`;
		print "\n", RESET;

		# [fixme] - Pretty bad way of doing this, either grep or improve parser
		parseJSON($response);
	};

	if ($js->{"Status"} =~ m/201 Created/){
		print BOLD "[ ", RESET;
		print BOLD GREEN "o ", RESET;
		print BOLD "] ", RESET;
		print BOLD "Obtained OAuth Token\n";
	}
	else {
		print BOLD "[ ", RESET;
		print BOLD RED "x ", RESET;
		print BOLD "] ", RESET;
		print BOLD "Unable to obtain OAuth Token\n", RESET;
		#print "      Status: ", $js->{"Status"}, "\n";
		cExit(1);
	}

	print "\n", RESET;



	# Set API key for use later so we don't have to parse config
	# [reviewme] - Maybe we should just parse config?
	$GITHUB_API = $js->{"token"};

	# Get repo information
	# If blank, give error
	print BOLD "[ ", RESET;
	print BOLD YELLOW "! ", RESET;
	print BOLD "] ", RESET;
	print BOLD "Repo information required\n", RESET;
	print "      Please provide owner that repo is under followed by repo name\n";
	print "      e.g. owner: nhmood, repo: watson (case sensitive)\n";
	print "      See help or README for more details on GitHub access\n\n";

	print BOLD "Owner: ", RESET;
	my $owner = <STDIN>;
	chomp $owner;
	if ($owner eq ""){
		print BOLD "[ ", RESET;
		print BOLD RED "x ", RESET;
		print BOLD "] ", RESET;
		print BOLD "Input blank. Please enter the owner the repo is under!\n", RESET;
		cExit(1);
	}
	print BOLD "Repo: ", RESET;
	my $repo = <STDIN>;
	chomp $repo;
	if ($repo eq ""){
		print BOLD "[ ", RESET;
		print BOLD RED "x ", RESET;
		print BOLD "] ", RESET;
		print BOLD "Input blank. Please enter the repo name!\n", RESET;
		cExit(1);
	}

	$js = do {
		my $call = "curl -s -i " .
				"-H 'Authorization: token $GITHUB_API' " .
				"https://api.github.com/repos/$owner/$repo/issues";
		my $response = `$call`;
		$js = parseJSON($response);
	};
	print "\n";

	if ($js->{"Status"} =~ m/200 OK/){
		print BOLD "[ ", RESET;
		print BOLD GREEN "o ", RESET;
		print BOLD "] ", RESET;
		print BOLD "Repo successfully accessed\n";
	}
	else {
		print BOLD "[ ", RESET;
		print BOLD RED "x ", RESET;
		print BOLD "] ", RESET;
		print BOLD "Unable to access /repo/$owner/$repo\n", RESET;
		#print "      Status: ", $js->{"Status"}, "\n";
		cExit(1);
	}
	print "\n";


	# [fixme] - Make modular status printer?
	print BOLD "[ ", RESET;
	print BOLD GREEN "+ ", RESET;
	print BOLD "] ", RESET;
	print BOLD "Creating label for watson on GitHub...\n", RESET;

	# Create label for watson
	my $call = "curl -s -i " .
		       "-H 'Authorization: token $GITHUB_API' " .
		       "https://api.github.com/repos/$owner/$repo/labels " .
		       "-d '{" .
		       		"\"name\" : \"watson\"," .
		       		"\"color\" : \"00AEEF\" }'";
	my $response = `$call`;
	$js = parseJSON($response);



	if ($js->{"Status"} =~ m/201 Created/){
		print BOLD "[ ", RESET;
		print BOLD GREEN "o ", RESET;
		print BOLD "] ", RESET;
		print BOLD "Label successfully created\n";
	}
	elsif ($js->{"code"} =~ m/already_exists/){
		print BOLD "[ ", RESET;
		print BOLD YELLOW "! ", RESET;
		print BOLD "] ", RESET;
		print BOLD "Label already exists\n";
	}
	else {
		print BOLD "[ ", RESET;
		print BOLD RED "x ", RESET;
		print BOLD "] ", RESET;
		print BOLD "Unable to access /repo/$owner/$repo\n", RESET;
		#print "      Status: ", $js->{"Status"}, "\n";
		cExit(1);
	}
	print "\n";



	# Check if RC exists
	# If it exists, basically replicate it and remove [github/bitbucket tag]
	my $nlc = 0;

	if (checkConfig()){
		debugPrint("Config exists, copying\n");
		open(my $in, "<", "$RCNAME");
		open(my $out, ">", "$RCNAME.new");
		my $section = "";
		while (my $line = <$in>){
			debugPrint("$line\n");
			# Regex for section
			if ($line =~ /^\[(\w+)\]/){
			    $section = $1;
			}


			# Check for newlines
			# If we already have 2 newlines before any actual content, skip
			# This is just to make the RC file output nicer looking
			if ($line eq "\n"){
				debugPrint("Newline found\n");
				if (++$nlc < 3){
					debugPrint("Less than 3 newlines so far, let it print\n");
					print $out $line;
				}
			}
			# If not in Github section, safe to copy
			# make $remotestr lowercase and check that + repo
			elsif ($section ne (lc("github")) &&
				   $section ne (lc("githubrepo"))){

				debugPrint("Not in git section, copying to new rc\n");
				print $out $line;
				# Reset newline count
				$nlc = 0;
			}

			debugPrint("line: $line");
			debugPrint("nlc: $nlc\n");


		}

		# Remove old RC file and replace with new one
		system("rm $RCNAME > /dev/null 2>&1");
		system("cp $RCNAME.new $RCNAME > /dev/null 2>&1");
		system("rm $RCNAME.new > /dev/null 2>&1");
	}

	# Append API token to end of file (old or new, doesn't matter now)
	open(my $file, "+>>", "$RCNAME");

	# Make sure there are only 2 newlines between items in RC
	print $file "\n" for $nlc .. 1;

	print $file "[github]\n";
	print $file ($GITHUB_API);
	print $file "\n\n\n";
	print $file "[githubrepo]\n";
	print $file "$owner/$repo";
	print $file "\n";
	close($file);



	print BOLD "[ ", RESET;
	print BOLD GREEN "o ", RESET;
	print BOLD "] ", RESET;
	print BOLD "GitHub successfully setup\n", RESET;
	print "      Issues will now automatically be updated on GitHub by default\n";
	#print "      Use -l, --local to not update against GitHub\n";
	print "      See help or README for more details on GitHub/Bitbucket access\n";
	print "\n";
	cExit(0);
}


###########################################################
# Github Issue Getter
###########################################################

# Post issues to github/bitbucket
sub getGithubIssues {
	# Only attempt if API is specified
	if (length($GITHUB_API) != 0){
		debugPrint("Getting GitHub Issues\n");
		# Get open tickets
		my $call = "curl -s -i " .
				   "-H 'Authorization: token $GITHUB_API' " .
				   "https://api.github.com/repos/$GITHUB_REPO/issues?labels\\=watson\\&state\\=open";
		$GITHUB_OPEN_ISSUES = `$call`;
		debugPrint($GITHUB_OPEN_ISSUES);

		# Check or a Status 200 OK, if not, API key might be invalid, warn user
		# Set GITHUB_VALID to 0 so that no remote related calls will be made
		if ($GITHUB_OPEN_ISSUES !~ m/200 OK/){
			$GITHUB_VALID = 0;
			wprint(BOLD "[ ", RESET);
			wprint(BOLD RED "x ", RESET);
			wprint(BOLD "] ", RESET);
			wprint("--> ", RESET);
			wprint(BOLD "Unable to access remote, GitHub API may be invalid\n");
			wprint(BOLD "          Consider running --remote (-r) option to regenerate key\n\n", RESET);
		}
		# Else get the closed tickets also and set GITHUB_VALID to 1
		else {
			$GITHUB_VALID = 1;
			$call = "curl -s -i " .
					"-H 'Authorization: token $GITHUB_API' " .
					"https://api.github.com/repos/$GITHUB_REPO/issues?labels\\=watson\\&state\\=closed";
			$GITHUB_CLOSED_ISSUES = `$call`;
			debugPrint($GITHUB_CLOSED_ISSUES);
		}
	}
	else {
		debugPrint("No GitHub API, ignoring issue list\n");
	}

}


###########################################################
# Github Issue Poster
###########################################################

# Post issues to github/bitbucket
sub postGithub {
	my ($issue) = @_;
	# Github API has been registered, post on Github
	if (length($GITHUB_API) != 0){

		# Check if md5 of issue has already been posted
		# [fixme] - if issue with same name in same file is made, won't ever get posted again :-/
		if ($GITHUB_OPEN_ISSUES !~ m/$issue->{md5}/ && $GITHUB_CLOSED_ISSUES !~ m/$issue->{md5}/){
			# Format title and body for creating issue
			# Title format: comment [basename of file], escape any '
			my $title = $issue->{file};
			$title =~ s/^(.+)\///;
			$title = "$issue->{comment} [" . $title . "]";
			# [fixme] - Figure out how to escape ' character on JSON post
			$title =~ s/\'//;


			debugPrint("Formatted title for GitHub Post : $title\n");

			# Format comment to escape any ' so JSON will be formatted properly
			my $body = "__filename__ : $issue->{file}\\n" .
					   "__line #__ : $issue->{linenumber}\\n" .
					   "__tag__ : $issue->{tag}\\n" .
					   "__md5__ : $issue->{md5}\\n";
			debugPrint("Formatted body for GitHub Post : $body\n");

			my $call = "curl -s -i " .
					   "-H 'Authorization: token $GITHUB_API' " .
					   "https://api.github.com/repos/$GITHUB_REPO/issues " .
					   "-d '{\"title\" : \"$title\", " .
					   "\"body\" : \"$body\", " .
					   "\"labels\" : [ \"watson\", \"$issue->{tag}\"]}'";
			debugPrint("Formatted call for GitHub Post : $call\n");
			my $response = `$call`;
			debugPrint($response);
		}
	}

	if (length($BITBUCKET_API) != 0){
		# Bitbucket Implementation
	}


}


###########################################################
# Bitbucket Setup
###########################################################

# Set up Bitbucket access
# [todo] - Only basic http auth, get OAuth for Bitbucket
# Bitbucket OAuth needs to redirect to some grant access page
# Not sure how to do that with a CLI, basic HTTP auth for now
sub bitbucketSetup {
	# JSON Response var
	my $js;

	# Set remote setup to one so password isn't asked for in Bitbucket parseConfig section
	# Crappy fix, won't need this when OAuth is implemented for Bitbucket
	$REMOTESETUP = 1;

	# [fixme] - Same code as header just without wprint, make modular
	print(BOLD "------------------------------\n");
	print(BOLD "watson", RESET);
	print(" - ");
	print(BOLD YELLOW "inline issue manager\n", RESET);
	print(BOLD "------------------------------\n\n");

	# [fixme] - Make modular status printer?
	print BOLD "[ ", RESET;
	print BOLD GREEN "+ ", RESET;
	print BOLD "] ", RESET;
	print BOLD "Attempting to access Bitbucket...\n", RESET;;

	# Parse config to make sure no previous API exists
	parseConfig() if checkConfig();

	if ( ($BITBUCKET_API  ne "") ||
	     ($BITBUCKET_REPO ne "") ){
		print BOLD "[ ", RESET;
		print BOLD RED "! ", RESET;
		print BOLD "] ", RESET;
		print BOLD "Previous Bitbucket Repo is in RC, are you sure you want to overwrite?\n", RESET;
		print "      (Y)es/(N)o: ";

		my $overwrite = <STDIN>;
		chomp $overwrite;
		print "\n";

		if ($overwrite eq "" || uc($overwrite) eq "NO" ||
			uc($overwrite) eq "N"){
			print BOLD "[ ", RESET;
			print BOLD RED "x ", RESET;
			print BOLD "] ", RESET;
			print BOLD "Not overwriting current Bitbucket repo info\n", RESET;
			cExit(1);
		}
	}


	print BOLD "[ ", RESET;
	print BOLD YELLOW "! ", RESET;
	print BOLD "] ", RESET;
	print BOLD "Access to your Bitbucket account required to make/update issues\n", RESET;

	print "      See help or README for more details on GitHub/Bitbucket access\n\n";

	print BOLD "[ ";
	print BOLD RED "! ", RESET;
	print BOLD "]", RESET;
	print BOLD " Bitbucket OAuth not implemented yet.\n", RESET;
	print "      Basic HTTP Auth in use, will request PW entry every time.\n\n";


	# Get username, clear newlines surrounding text
	# If blank, give error
	print BOLD "Username: ", RESET;
	my $username = <STDIN>;
	chomp $username;
	if ($username eq ""){
		print BOLD "[ ", RESET;
		print BOLD RED "x ", RESET;
		print BOLD "] ", RESET;
		print BOLD "Input blank. Please enter your username!\n", RESET;
		cExit(1);
	}

	print "\n";
	# cURL to get OAuth Token, returns JSON


	# Get repo information
	# If blank, give error
	print BOLD "[ ", RESET;
	print BOLD YELLOW "! ", RESET;
	print BOLD "] ", RESET;
	print BOLD "Repo information required\n", RESET;
	print "      Please provide owner that repo is under followed by repo name\n";
	print "      e.g. owner: nhmood, repo: watson (case sensitive)\n";
	print "      See help or README for more details on GitHub access\n\n";


	print BOLD "Owner: ", RESET;
	my $owner = <STDIN>;
	chomp $owner;
	if ($owner eq ""){
		print BOLD "[ ", RESET;
		print BOLD RED "x ", RESET;
		print BOLD "] ", RESET;
		print BOLD "Input blank. Please enter the owner the repo is under!\n", RESET;
		cExit(1);
	}
	print BOLD "Repo: ", RESET;
	my $repo = <STDIN>;
	chomp $repo;
	if ($repo eq ""){
		print BOLD "[ ", RESET;
		print BOLD RED "x ", RESET;
		print BOLD "] ", RESET;
		print BOLD "Input blank. Please enter the repo name!\n", RESET;
		cExit(1);
	}

	print "\n";

	my $call;
	my $response;

	$call = "curl -s -i " .
			"https://bitbucket.org/api/1.0/repositories/$owner/$repo " .
			"-u $username";
	print BOLD;
	$response = `$call`;
	print "\n", RESET;
	# [fixme] - Pretty bad way of doing this, either grep or improve parser
	if ($response =~ m/HTTP\/1.1 200 OK/){
		print BOLD "[ ", RESET;
		print BOLD GREEN "o ", RESET;
		print BOLD "] ", RESET;
		print BOLD "Successfully accessed remote repo with given credentials\n";
	}
	else {
		print BOLD "[ ", RESET;
		print BOLD RED "x ", RESET;
		print BOLD "] ", RESET;
		print BOLD "Unable to access remote repo with given credentials\n", RESET;
		print BOLD "Check that credentials are correct and repository exists under owner\n", RESET;
		#print "      Status: ", $js->{"Status"}, "\n";
		cExit(1);
	}

	print "\n", RESET;



	# Check if RC exists
	# If it exists, basically replicate it and remove [github/bitbucket tag]
	my $nlc = 0;

	if (checkConfig()){
		debugPrint("Config exists, copying\n");
		open(my $in, "<", "$RCNAME");
		open(my $out, ">", "$RCNAME.new");
		my $section = "";
		while (my $line = <$in>){
			debugPrint("$line\n");
			# Regex for section
			if ($line =~ /^\[(\w+)\]/){
			    $section = $1;
			}


			# Check for newlines
			# If we already have 2 newlines before any actual content, skip
			# This is just to make the RC file output nicer looking
			if ($line eq "\n"){
				debugPrint("Newline found\n");
				if (++$nlc < 3){
					debugPrint("Less than 3 newlines so far, let it print\n");
					print $out $line;
				}
			}
			# If not in bitbucket or github section, safe to copy
			# make $remotestr lowercase and check that + repo
			elsif ( $section ne (lc("bitbucket"))  &&
				    $section ne (lc("bitbucketrepo")) ){


				debugPrint("Not in bitbucket section, copying to new rc\n");
				print $out $line;
				# Reset newline count
				$nlc = 0;
			}

			debugPrint("line: $line");
			debugPrint("nlc: $nlc\n");


		}

		# Remove old RC file and replace with new one
		system("rm $RCNAME > /dev/null 2>&1");
		system("cp $RCNAME.new $RCNAME > /dev/null 2>&1");
		system("rm $RCNAME.new > /dev/null 2>&1");
	}

	# Append API token to end of file (old or new, doesn't matter now)
	open(my $file, "+>>", "$RCNAME");

	# Make sure there are only 2 newlines between items in RC
	print $file "\n" for $nlc .. 1;

	# Store username in bitbucket api section since we don't OAuth yet
	print $file "[bitbucket]\n";
	print $file "$username\n";
	print $file "\n\n";
	print $file "[bitbucketrepo]\n";
	print $file "$owner/$repo";
	print $file "\n";
	close($file);

	print BOLD "[ ", RESET;
	print BOLD GREEN "o ", RESET;
	print BOLD "] ", RESET;
	print BOLD "Bitbucket successfully setup\n", RESET;
	print "      Issues will now automatically be updated on Bitbucket by default\n";
	print "      Use -l, --local to not update against GitHub\n";
	print "      See help or README for more details on GitHub/Bitbucket access\n";
	print "\n";
	cExit(0);
}


###########################################################
# Bitbucket Issue Getter
###########################################################

# Post issues to github/bitbucket
sub getBitbucketIssues {
	# Only attempt if repo is specified
	if (length($BITBUCKET_REPO) != 0){
		debugPrint("Getting Bitbucket Issues\n");

		print BOLD "Bitbucket password required for remote checking/posting: ", RESET;
		system("stty -echo");
		my $pw = <STDIN>;
		chomp $pw;
		system("stty echo");
		print "\n";
		if ($pw eq ""){
			print BOLD "[ ", RESET;
			print BOLD RED "x ", RESET;
			print BOLD "] ", RESET;
			print BOLD "Input blank. Will not check/update against Bitbucket\n", RESET;
			$BITBUCKET_PW = "";
			$BITBUCKET_VALID = 0;
			return 1;
		}
		else {
			$BITBUCKET_PW = $pw;
		}

		# Get all issues, Bitbucket differentiates between open/new so we can just look for all
		# The open issue var is used only for preventing posting again anyways
		# Only need closed ones to update final output, might change in Github too?
		my $call = "curl -s -i " .
				   "https://bitbucket.org/api/1.0/repositories/$BITBUCKET_REPO/issues " .
				   "-u $BITBUCKET_API:$pw";
		$BITBUCKET_OPEN_ISSUES = `$call`;
		debugPrint($BITBUCKET_OPEN_ISSUES);

		# Check for a Status
		if ($BITBUCKET_OPEN_ISSUES !~ m/HTTP\/1.1 200 OK/){
			$BITBUCKET_VALID = 0;
			wprint(BOLD "[ ", RESET);
			wprint(BOLD RED "x ", RESET);
			wprint(BOLD "] ", RESET);
			wprint("--> ", RESET);
			wprint(BOLD "Unable to access remote, Bitbucket settings may be invalid\n");
			wprint(BOLD "          Consider running --remote (-r) option to regenerate settings\n\n", RESET);
		}
		# Else get the closed tickets also and set BITBUCKET_VALID to 1
		else {
			$BITBUCKET_VALID = 1;
			$call = "curl -s -i " .
					"https://bitbucket.org/api/1.0/repositories/$BITBUCKET_REPO/issues?status\\=resolved " .
					"-u $BITBUCKET_API:$pw";

			$BITBUCKET_CLOSED_ISSUES = `$call`;
			debugPrint($BITBUCKET_CLOSED_ISSUES);
		}
	}
	else {
		debugPrint("No Bitbucket Repo, ignoring issue list\n");
	}
}


###########################################################
# Bitbucket Issue Poster
###########################################################

# Post issues to github/bitbucket
sub postBitbucket {
	my ($issue) = @_;
	# Bitbucket API has been registered, post on Github
	if (length($BITBUCKET_API) != 0){
		# Check if md5 of issue has already been posted
		# [fixme] - if issue with same name in same file is made, won't ever get posted again :-/
		if ($BITBUCKET_OPEN_ISSUES !~ m/$issue->{md5}/ && $BITBUCKET_CLOSED_ISSUES !~ m/$issue->{md5}/){
			# Format title and body for creating issue
			# Title format: comment [basename of file], escape any '
			my $title = $issue->{file};
			$title =~ s/^(.+)\///;
			$title = "$issue->{comment} [" . $title . "]";
			# [fixme] - Figure out how to escape ' character on JSON post
			# Remove ' for now
			$title =~ s/\'//;
			# Since not JSON, need to replace spaces with +
			$title =~ s/\s/\+/g;

			debugPrint("Formatted title for Bitbucket Post : $title\n");

			# %0D%0A at end so newlines will show up properly on Bitbucket
			my $body = "__filename__ : $issue->{file}%0D%0A%0D%0A  " .
					   "__line #__ : $issue->{linenumber}%0D%0A%0D%0A  " .
					   "__tag__ : $issue->{tag}%0D%0A%0D%0A  " .
					   "__md5__ : $issue->{md5}%0D%0A%0D%0A  ";
			debugPrint("Formatted body for Bitbucket Post : $body\n");
			# Replace spaces with + like above
			$body =~ s/\s/\+/g;

			# Format call, pass all params as -d to avoid \= \&
			my $call = "curl -s -i " .
					   "https://bitbucket.org/api/1.0/repositories/$BITBUCKET_REPO/issues " .
					   "-d 'title=$title&" .
					   "content=$body' " .
					   "-u $BITBUCKET_API:$BITBUCKET_PW";
			# If you allow this to print below pw will show up as plain text!
			debugPrint("Formatted call for Bitbucket Post : $call\n");
			my $response = `$call`;
			debugPrint($response);
		}
	}
}


##########################
# Box glyph, e.g [!], [x]
##########################

sub box {
	my $content = join '', @_;
	return BOLD, "[ ", RESET, $content, RESET, BOLD, " ]", RESET;
}

# kate: space-indent off; indent-width 4; mixedindent off; indent-mode cstyle;