#!/usr/bin/perl
# watson - inline issue manager
# nhmood @ [goosecode labs] | 2012
# Copyright (c) 2012-2013 goosecode labs
# This content is licensed under the MIT License
# See the file LICENSE for copying permission


# [todo] - add priority listing for tags and todo
# [todo] - generate .html file with report
# [todo] - add text editor/jump to code for each item in .html report
# [todo] - if x is placed in todo [!] then move it to separate file
# [todo] - store in separate file or parse every time? (thinking parse)
# [todo] - tell when directory changes with some header
# [todo] - change @IGNOREDIR to hash instead of array for efficiency
# [todo] - only allow user to check executing users files (setuid exploit)
# [todo] - wrap printed lines around 80 characters
# [todo] - command line option to remove remote repos
# [todo] - replace json parser with just grep? need to get status if failed
# [todo] - add ability to update issue if same title but different md5
# [todo] - implement local only reporting (make it default?)
# [todo] - progress bar for obtaining github/bitbucket issue list
# [todo] - local should be default, must use -r or remote flag to post and check?
#		 - maybe have it check against background unless -local is passed
#		 - but dont post unless --post is used (make it faster?)
# [todo] - add status indicator for remote requests
#		 - we know # of requests and which we are on, can do it that way
# [todo] - change github issue checks to -d instead of issue?key=val
# [todo] - add remote / local options and necessary logic
# [todo] - replace open/closed issue var with just all and closed?

###########################################################
# Global parameters 
###########################################################

# For testing
#use strict;
#use warnings;

# For color print outs
use Term::ANSIColor qw(:constants);

# Route Ctrl-C to cExit to clean up results 
$SIG{'INT'} = \&cExit;

# For debugging (print data structures)
use Data::Dumper;

# For MD5 Sum (issue posting check)
use Digest::MD5 qw(md5_hex);

# App Config
my $DEBUG = $ENV{WATSON_DEBUG};
my $RCNAME = ".watsonrc";		# Change config file name
my $TMPOUT = ".watsonresults";	# Change tmp file name

# Global variables
my @DIRS;
my @FILES;
my @TAGS;
my @IGNORE;
my @STRUCTURE;
my $REMOTESETUP = 0;
my $GITHUB_VALID = 0;
my $GITHUB_API;
my $GITHUB_REPO;
my $GITHUB_OPEN_ISSUES;
my $GITHUB_CLOSED_ISSUES;
my $BITBUCKET_VALID = 0;
my $BITBUCKET_API;
my $BITBUCKET_PW;
my $BITBUCKET_REPO;
my $BITBUCKET_OPEN_ISSUES;
my $BITBUCKET_CLOSED_ISSUES;
my $MAX_DEPTH = 0;
my $DEPTH = 0;
my $IGNORE_RC_DIRS = 0;
my $IGNORE_RC_FILES = 0;
my $IGNORE_RC_TAGS = 0;
my $IGNORE_RC_IGNORE = 0;
my $HASLESS = 0;
my $HASCURL = 0;
my $LESSOUT;


use constant GITHUB => 0;
use constant BITBUCKET => 1;


#----------------------------------------------------------
###########################################################
# Main Program 
###########################################################
#----------------------------------------------------------

checkLess();
checkcURL();
printHeader();
parseCommandLine();
checkConfig();
parseConfig();
startScan();
createReport();


#----------------------------------------------------------
###########################################################
# Functions 
###########################################################
#----------------------------------------------------------


###########################################################
# Header Print 
###########################################################

# Print watson header
sub printHeader {
	wprint(BOLD "------------------------------\n");
	wprint(BOLD "watson", RESET);
	wprint(" - ");
	wprint(BOLD YELLOW "inline issue manager\n\n", RESET);
	$pwd = `pwd`;
	wprint("Run in: $pwd");
	$time = localtime;
	wprint("Run @ $time\n");
	wprint(BOLD "------------------------------\n\n");
	return 1;
}


###########################################################
# Help Print 
###########################################################

# Print watson help 
sub printHelp {
	print BOLD;
	print "Usage: watson [OPTION]...\n";
	print "Running watson with no arguments will parse with settings in RC file\n";
	print "If no RC file exists, default RC file will be created\n";

	print "\n";
	print "   -d, --dirs			list of directories to search in\n";
	print "   -f, --files			list of files to search in\n";
	print "   -h, --help			print help\n";
	print "   -i, --ignore			list of files, directories, or types to ignore\n";
	print "   -p, --parse-depth		depth to recursively parse directories\n";
	print "   -r, --remote			list / create tokens for Bitbucket/Github\n";
	print "   -t, --tags			list of tags to search for\n";
	#print "   -u, --update          update remote repos with current issues\n";
	print "   -v, --version		print watson version and info\n";
	print "\n";

	print "Any number of files, tags, dirs, and ignores can be listed after flag\n";
	print "Ignored files should be space separated\n";
	print "To use *.filetype identifier, encapsulate in \"\" to avoid shell substitutions \n";
	print "\n";

	print "Report bugs to: watson\@goosecode.com\n";
	print "watson home page: <http://goosecode.com/projects/watson>\n";
	print "[goosecode] labs | 2012-2013\n";
	print RESET;
	return 1;
}


###########################################################
# Help Print 
###########################################################

# Print watson help 
sub printVersion {

	print "watson v1.3\n";
	print "Copyright (c) 2012-2013 goosecode labs\n";
	print "Licensed under MIT, see LICENSE for details\n";
	print "\n";

	print "Written by nhmood, see <http://goosecode.com/projects/watson>\n";
	return 1;
}


###########################################################
# Clean Exit
###########################################################

# Clean exit function that removes temp files
sub cExit {
	my ($ex) = @_;
	# Clean up temp file(s)
	system("rm $TMPOUT > /dev/null 2>&1");

	# If exit status is INT(terupt), set to 1 and print newline	
	if ($ex eq "INT"){ $ex = 1; print "\n"; }
	exit $ex;
}


###########################################################
# Debug Print
###########################################################

# Debug print statements that are only enabled
# when debug flag is set (top of file)
sub debugPrint {
	if ($DEBUG){
		print @_;
	}
	return 1;
}


###########################################################
# Output Print
###########################################################

# If system has less, dump all output to .tmp file and use less
# If no less, just print straight to stdout
sub wprint {
	my ($line) = @_;
	
	if ($HASLESS){
		print $LESSOUT "$line";
		return 1;
	}
	else {
		print "$line";
		return 0;
	}
}


###########################################################
# Unix less Checker
###########################################################

# Check to see if system has less
# If so, set flag and open tmp file
sub checkLess {
	if (! system("which less > /dev/null 2>&1") ){
		open($LESSOUT, "+>", $TMPOUT);
		$HASLESS = 1;
		return 1;
	}
	else {
		return 0;
	}
}


###########################################################
# cURL Checker
###########################################################

# Check to see if system has cURL
# If so, set flag
sub checkcURL {
	if (! system("which curl > /dev/null 2>&1") ){
		$HASCURL = 1;
		return 1;
	}
	else {
		return 0;
	}
}


###########################################################
# Directory checker  
###########################################################

# checkDir - checks if directory can be opened 
# Different from just using -d, checks if able to OPEN
sub checkDir {
	my ($dir) = @_;
	# Error check for input
	if (length($dir) == 0){
		wprint("No directories specified.\n");
		return 0;
	}
	# Check if directory can be opened
	my $success = opendir(my $tDIR, $dir);
	if (!$success){
		wprint("Cannot open dir: |$dir|, skipping.\n");
		return 0;
	}

	closedir($tDIR);
	debugPrint("|$dir| exists and opened successfully.\n");
	return 1;
}


###########################################################
# File checker  
###########################################################

# checkFile - checks if file can be opened
# Different from just using -f, checks if able to OPEN
sub checkFile {
	my ($file) = @_;
	# Error check for input
	if (length($file) == 0){
		wprint("No file specified.\n");
		return 0;
	}

	# Check if file can be opened
	my $success = open(my $tFILE, $file);
	if (!$success){
		wprint("Could not open |$file|, skipping.\n");
		return 0;
	}

	close($tFILE);
	debugPrint("|$file| exists and opened successfully.\n");
	return 1;
}


###########################################################
# Config file check
###########################################################

# Check for config file in same dir as watson
# If it doesn't exist, create the default one
sub checkConfig {
	# Should have individual .rc for each dir that watson is in
	# This allows you to keep different preferences for different projects
	
	# Check for rc
	# -z checks if filesize is 0
	debugPrint("[Checking for $RCNAME] \n");
	if (! -e "$RCNAME"){
		debugPrint("$RCNAME not found! \n");
		debugPrint("Creating default $RCNAME \n");
	
		# Create default rc
		createRC("$RCNAME");
		return 0;
	}
	else {
		debugPrint("$RCNAME found \n\n");
		return 1;
	}
}


###########################################################
# Default config file writer 
###########################################################

# Create default RC file with some generic settings
sub createRC {
	my ($file_name) = @_;
	open(my $file, "+>>", "$RCNAME");
# [fixme] - Figure out a way to indent this?
my $rcdefault = <<EOF; 
# watson rc
# watson - inline issue manager
# [goosecode] labs / 2012


# Directories 
[dirs] 
./

 
# Tags 
[tags] 
fix
review
todo


# Ignores
[ignore]
.git
.swp
EOF

	debugPrint($rcdefault);
	# Print default rc above to specified file
	# [fixme] - Get return 
	my $success = print $file $rcdefault;
	close($file);
	return $success;
}


###########################################################
# Command line parser 
###########################################################

# Parse command line arguments
sub parseCommandLine {
	debugPrint("[Checking CL args]\n");
	debugPrint("Total args: ", $#ARGV + 1, "\n");

	my @opts = ("-d", "--dirs", 
				"-f", "--files",
				"-h", "--help", 
				"-t", "--tags",
				"-p", "--parse-depth",
				"-i", "--ignore",
				"-r", "--remote",
				"-u", "--update"); 


	# Check number of command lines, skip if invalid
	if ($#ARGV > -1){
		for (my $i = 0; $i < $#ARGV + 1; $i++){
			debugPrint("Main Index: $i: $ARGV[$i]\n");		
		
			if ($ARGV[$i] eq "-h" || $ARGV[$i] eq "--help"){
				debugPrint("Help flag passed\n");
				printHelp();		
				cExit(0);
			}

			if ($ARGV[$i] eq "-v" || $ARGV[$i] eq "--version"){
				debugPrint("Version flag passed\n");
				printVersion();
				cExit(0);
			}
	
			if ($ARGV[$i] eq "-p" || $ARGV[$i] eq "--parse-depth"){
				debugPrint("Parse Depth flag passed\n");
				# Check to make sure next param is a valid number (non-negative)
				if ( $ARGV[$i + 1] =~ m/^([0-9]+)$/ ){
					$MAX_DEPTH = $ARGV[$i + 1];
					debugPrint("Valid parse depth: $MAX_DEPTH\n");
				}
				else {
					wprint(BOLD "[ ", RESET);
					wprint(BOLD MAGENTA "! ", RESET);
					wprint(BOLD "] ", RESET);
					wprint("--> ", RESET);
					wprint("Invalid parse depth passed\n");
				}
				
				# Move index to two after (flag and value)
				$i = $i + 2;

			}

			if ($ARGV[$i] eq "-r" || $ARGV[$i] eq "--remote"){
				debugPrint("Remote Flag passed\n");

				# When generating OAuth Token for github/bitbucket
				# no other params should be passed
				if ($i != 0 || $#ARGV > 1){
					debugPrint("Not the first flag, exiting\n");
					print BOLD "[ ", RESET;
					print BOLD RED "x ", RESET;
					print BOLD "] ", RESET;
					print "Please run remote flag alone to generate GitHub/Bitbucket OAuth token\n";
					print "      See help for more details\n";
					cExit(1);
				}
				
				# Can only do this if we have cURL on the system
				if (! $HASCURL ){
					print BOLD "[ ", RESET;
					print BOLD RED "x ", RESET;
					print BOLD "] ", RESET;
					print "It looks like you don't have cURL\n";
					print "      We currently only support remote issues if you have cURL\n";
					print "      Make sure cURL is installed and in your PATH\n";
					cExit(1);
				}

				if 	  (lc($ARGV[$i + 1]) eq "bitbucket"){ bitbucketSetup(); }
			   	elsif (lc($ARGV[$i + 1]) eq "github"   ){ githubSetup(); }
				elsif ($ARGV[$i + 1] eq "")  {
						# Check if config exists, if so, parse it
						checkConfig() ? parseConfig() : true;

						if ($BITBUCKET_API eq "" && $GITHUB_API eq "") {
							print BOLD "[ ", RESET;
							print BOLD RED "x ", RESET;
							print BOLD "] ", RESET;
							print BOLD "No remotes currently exist\n", RESET;
							print BOLD "      Pass github or bitbucket to watson -r to add\n", RESET;
							print "      That's all we support right now :(\n";
							print "      See help for more details\n";
							cExit(1);
						}

						if ($BITBUCKET_API ne ""){
							print BOLD "[ ", RESET;
							print BOLD GREEN "Bitbucket ", RESET;
							print BOLD "]\n", RESET;
							print BOLD "   Bitbucket User :", RESET, " $BITBUCKET_API\n";
							print BOLD "   Bitbucket Repo :", RESET, " $BITBUCKET_REPO\n";
							print "\n";
						}
						
						if ($GITHUB_API ne ""){
							print BOLD "[ ", RESET;
							print BOLD GREEN "GitHub ", RESET;
							print BOLD "]\n", RESET;
							print BOLD "   GitHub Key  :", RESET, " $GITHUB_API\n";
							print BOLD "   GitHub Repo :", RESET, " $GITHUB_REPO\n";
							print "\n";
						}

						cExit(1);
				}
				else {
					print BOLD "[ ", RESET;
					print BOLD RED "x ", RESET;
					print BOLD "] ", RESET;
					print BOLD "Incorrect argument\n", RESET;
					print "      Please specify either github or bitbucket to setup remote\n";
					print "      Or pass without argument to see current remotes\n";
					print "      See help for more details\n";
					cExit(1);
				}
				
			}


			if ($ARGV[$i] eq "-d" || $ARGV[$i] eq "--dirs"){
				debugPrint("Dir flag passed\n");
				# Keep track of number of args for when we exit loop
				my $count = 0;

				# Keep checking following options until another flag or end
				for (my $j = $i + 1; $j < $#ARGV + 1; $j++){
					# [fixme] - better way to check if its not a flag?
					if (!grep /$ARGV[$j]/, @opts){ 
		
						debugPrint("Dir Index: $j: $ARGV[$j]\n");
						$count++;	
						if (checkDir($ARGV[$j])){
	
							debugPrint("dirflag: {$ARGV[$j]} valid directory, added from CL.\n");
	
							# If we ever get into this, means CL passed
							# Set RC ignore so we don't look at rc
							debugPrint("Ignoring RC Files/Dirs\n\n");
							$IGNORE_RC_DIRS = 1;
	
							# Remove trailing slashes
							$ARGV[$j] =~ s/(\/)+$//;
							push(@DIRS, $ARGV[$j]);
						}
					}
					else {
						debugPrint("Found a flag: $ARGV[$j]\n");
						last;
					}
				}
				# Set main loop index to correct value
				$i += $count;
				
			}
		

			if ($ARGV[$i] eq "-f" || $ARGV[$i] eq "--files"){
				debugPrint("File flag passed\n");
				# Keep track of number of args for when we exit loop
				my $count = 0;	

				# Keep checking following options until another flag or end
				for (my $j = $i + 1; $j < $#ARGV + 1; $j++){
					# [fixme] - better way to check if its not a flag?
					if (!grep /$ARGV[$j]/, @opts){ 
			
						debugPrint("File Index: $j: $ARGV[$j]\n");
						$count++;	
						if (checkFile($ARGV[$j])){
					
							debugPrint("fileflag: {$ARGV[$j]} valid file, added from CL.\n");	
	
							# If we ever get into this, means CL passed
							# Set RC ignore so we don't look at rc
							debugPrint("Ignoring RC Files/Dirs\n\n");
							$IGNORE_RC_FILES = 1;
	
							push(@FILES, $ARGV[$j]);
						}
					}
					else {
						debugPrint("Found a flag: $ARGV[$j]\n");
						last;
					}
				}
				# Set main loop index to correct value
				$i += $count;
			}
	
	
			if ($ARGV[$i] eq "-t" || $ARGV[$i] eq "--tags"){
				debugPrint("Tag flag passed\n");
				# Keep track of number of args for when we exit loop
				my $count = 0;

				# Keep checking following options until another flag or end
				for (my $j = $i + 1; $j < $#ARGV + 1; $j++){
					# [fixme] - better way to check if its not a flag?
					if (!grep /$ARGV[$j]/, @opts){ 
					
						debugPrint("Tag Index: $j: $ARGV[$j]\n");
						$count++;	
						
						debugPrint("tagflag: {$ARGV[$j]} added from CL.\n");	
	
						# If we ever get into this, means CL passed
						# Set RC ignore so we don't look at rc
						debugPrint("Ignoring RC tags\n\n");
						$IGNORE_RC_TAGS = 1;
	
						push(@TAGS, $ARGV[$j]);
					}
					else {
						debugPrint("Found a flag: $ARGV[$j]\n");
						last;
					}
				}
				# Set main loop index to correct value
				$i += $count;
			}
	

			if ($ARGV[$i] eq "-i" || $ARGV[$i] eq "--ignore"){
				debugPrint("Ignore flag passed\n");
				# Keep track of number of args for when we exit loop				
				my $count = 0;

				# Keep checking following options until another flag or end
				for (my $j = $i + 1; $j < $#ARGV + 1; $j++){
					# [fixme] - better way to check if its not a flag?
					if (!grep /$ARGV[$j]/, @opts){ 
					
						debugPrint("Ignore Index: $j: $ARGV[$j]\n");
						$count++;	
						
						debugPrint("ignoreflag: {$ARGV[$j]} added from CL.\n");	
	
						# If we ever get into this, means CL passed
						# Set RC ignore so we don't look at rc
						debugPrint("Ignoring RC ignore\n\n");
						$IGNORE_RC_IGNORE = 1;
	
						push(@IGNORE, $ARGV[$j]);
					}
					else {
						debugPrint("Found a flag: $ARGV[$j]\n");
						last;
					}
				}
				# Set main loop index to correct value
				$i += $count;
			}
		}
	}
	else {
		debugPrint("No command line arguments passed.\n\n");	
	}
	return 1;
}


###########################################################
# Config file parser
###########################################################

# Go through config file and determine dirs, tags, and ignores to use
sub parseConfig {
	# Parse rc
	debugPrint("Parsing $RCNAME\n");
	
	open(my $rc, "<", "$RCNAME");
	
	# Add . and .. and .git to ignorelist 
	push(@IGNORE, ".");
	push(@IGNORE, "..");
	push(@IGNORE, "*.swp");
	push(@IGNORE, ".watsonrc");
	push(@IGNORE, $TMPOUT);
	
	
	# Read rc line by line
	my $section = "";
	while (my $line = <$rc>){
	    debugPrint($line);
	    
		# Ignore full line comments
	    if ($line !~ m/^#/ && $line =~ /\S/){
			# Regex to find [section], store into $section and continue to the
			# next line until a new section
			if ($line =~ /^\[(\w+)\]/){
			    $section = $1;
			    next;
			}
	    	
			# If @DIRS or @FILES wasn't populated by CL args, populate from rc
			if ($section eq "dirs"){
			    if ($IGNORE_RC_DIRS == 1 || $IGNORE_RC_FILES == 1) {
					debugPrint("Directories set from command line, ignoring rc [dirs]!\n");
			    }
			    else {
	    	        # Regex for dirs, then push to @DIRS
					$line =~ /^((\.?\/?\w?+\/?)+)/;
					$line = $1;
					$line =~ s/(\/)+$//;
					debugPrint("dirs: $line added from rc. \n");
					push(@DIRS, $line);
			    }
			}
			
			# If @TAGS wasn't populated by CL args, populate from rc
			elsif ($section eq "tags"){
			    if ($IGNORE_RC_TAGS == 1) {
					debugPrint("Directories set from command line, ignoring rc [dirs]!\n");
			    }
				else {
					# Regex for tags, then push to @TAGS
			    	$line =~ /^(\w+( \| [0-9])?)/;
			    	debugPrint("tags: $1 added from rc. \n");
			    	push(@TAGS, $1);
				}
			}
	
			# If @IGNORE wasn't populated by CL args, populate from rc
			elsif ($section eq "ignore"){
			    if ($IGNORE_RC_IGNORE == 1) {
					debugPrint("Directories set from command line, ignoring rc [dirs]!\n");
			    }
				else {
					# Regex for dirs to ignore, then push to @IGNOREDIR

					$line =~ /^((\/?\w+\/?)+)/;
					$line = $1;
					$line =~ s/(\/)+$//;
					debugPrint("ignore: $line added from rc.\n");
					push(@IGNORE, $line);
				}
			}
			elsif ($section eq "github"){
				# No need for regex on API key
				debugPrint("GitHub API: $line\n");
				chomp($line);
				$GITHUB_API = $line;
			}
			elsif ($section eq "bitbucket"){
				# No need for regex on API key
				debugPrint("Bitbucket API: $line\n");
				chomp($line);
				$BITBUCKET_API = $line;
			}
			elsif ($section eq "githubrepo"){
				# No need for regex on repo
				debugPrint("GitHub Repo: $line\n");
				chomp($line);
				$GITHUB_REPO = $line;

				# If setting up remote, don't ask for password / do any remote stuff
				# Won't need this when OAuth implemented but it does optimize the code...
				if (!$REMOTESETUP){
					# Get list of issues, also checks if API key is valid
					getGithubIssues();
				}
			}
			elsif ($section eq "bitbucketrepo"){
				# No need for regex on repo
				debugPrint("Bitbucket Repo: $line\n");
				chomp($line);
				$BITBUCKET_REPO = $line;

				# If setting up remote, don't ask for password / do any remote stuff
				# Won't need this when OAuth implemented but it does optimize the code...
				if (!$REMOTESETUP){
					# Get list of issues, also checks if API key is valid	
					getBitbucketIssues();
				}
			}

	    } 
	}

	debugPrint("\n\n\n");
	close($rc);
	return 1;
}	


###########################################################
# File/Folder Parser Wrapper
###########################################################

# Start going through all files and subdirs of specified folder
sub startScan{
	
	# If files passed to command line, push those to structure
	# Have to populate structure this way to print properly
	if ($IGNORE_RC_FILES){
		# For each file obtained from CL (if any) parse file
		# Create proper structure for files so we can push to @STRUCTURE
		my $structure = {};
		my @tfiles = ();
		foreach my $file (@FILES){
			push(@tfiles, parseFile($file));
		}
		
		$structure->{files} = \@tfiles;
		push(@STRUCTURE, $structure);
	}

	# For each directory obtained from rc or CL, look for files in them
	# This will always be valid, not condition like files above
	foreach my $dir (@DIRS){
		push(@STRUCTURE, parseDirs($dir));
		# Reset DEPTH on directories specified (not dirs found within)
		$DEPTH = 0;
	}

	wprint("\n");
	return 1;
}


###########################################################
# Directory Parser
###########################################################

# Look through directory for files to parse
sub parseDirs {
	my ($dir) = @_;
	debugPrint("parseDirs: |$dir|\n");

	my @pdirs;		# subdirectories found
	my @pfiles;		# files found

	

	# Error check for input
	if (!checkDir($dir)){
		return 0;
	}
	
	# [fixme] - add option to stop from going deeper dirs (depth?)
	# Loop through all entries in directory
	debugPrint("Looping through all files/folders in |$dir|\n");

	# Open dir and get list of all files	
	opendir(my $wd, $dir);
	my @dirlist = sort(readdir($wd));

	foreach my $entry (@dirlist){
		# Create singular $path var to parse
		# Remove trailing slashes
		$dir =~ s/^(\/)+$//;
		
		# Combine dir and entry to make full path
		my $path = "$dir/$entry";

		# Remove leading ., /, or ./
		$path =~ s/^((\.)?(\/)?)//; 

		debugPrint("path: |$path|\n");

		# Make sure it isn't part of ignored list
		# If it is, set to "", won't pass dir/file check
		# [reviewme] - Should we warn users when file is ignored on stdout?
		foreach my $ignore (@IGNORE){
			# Check for any *.type in ignore list (list .swp)
			# Regex to see if extension is .type, ignore if so 
			if ( substr($ignore, 0, 1) eq "*" ){
				my $ignoretype = substr($ignore, 1);
				if ( $entry =~ m/$ignoretype$/ ){
					debugPrint("|$path| is on the ignore list, setting to nothing\n");
					$path = "";
				}
			}
			elsif ("$entry" eq "$ignore" | "$path" eq "$ignore"){
				debugPrint("|$path| is on the ignore list, setting to nothing\n");
				$path = "";
				last;
			}
		}
		
		# Check if entry is a file, if so parse
		if (-f "$path"){
			debugPrint("|$path| is a file!\n");
			push(@pfiles, parseFile("$path"));
		}

		# Check if entry is dir, if so parse
		elsif (-d "$path"){
			debugPrint("|$path| is a dir!\n");

			# If MAX_DEPTH is 0, no limit on subdirs
			# Increment DEPTH, compare with MAX_DEPTH
			# If less than depth, parse dir, else ignore
			$DEPTH++;
			debugPrint("Folder depth: $DEPTH\n");
			if ($MAX_DEPTH == 0){
				debugPrint("No max depth, parsing folders\n");
				push(@pdirs, parseDirs("$path"));
			}
			elsif ($DEPTH < $MAX_DEPTH){
				debugPrint("Depth less than Max depth, parsing folder\n");
				push(@pdirs, parseDirs("$path"));
			}
			else {
				debugPrint("Depth greater than Max depth, ignoring\n");
			}

		}

		# Add directory to ignore list so it isn't repeated again
		push(@IGNORE, $path);
		
	}

	closedir($wd);
	# Create has to hold all parsed files and folders
	my $structure = {};

	# Still confused as to what this is actually doing but...
	# Storing an array of hashes into structure->file hash
	# I THINK?? that because the array consists of hashes (references)
	# the \@pfiles will copy the actual values (or keep the references alive?)
	# Either way, some scoping thing is solved with \@
	
	$structure->{files} = \@pfiles;
	$structure->{dirs} = \@pdirs;

	return $structure;
}


###########################################################
# File Parser
###########################################################

sub parseFile {
	# [fixme] - need a better check for valid files (when using @_)
	my ($file) = @_;
	debugPrint("parseFile: |$file|\n");

	# Error check for input
	if (!checkFile($file)){
		return 0;
	}

	# Get filetype and set corresponding comment type
	my $comment = getComment($file);
	if (!$comment){
		print(BOLD "[ ", RESET);
		print(BOLD MAGENTA "! ", RESET);
		print(BOLD "] ", RESET);
		print("--> ", RESET);
		print("Couldn't determine filetype for $file, using # as comment\n", RESET);
		$comment = "#";
	}

	# Open file and seek to beginning
	open(my $wf, "<", $file);
	seek($wf, 0, 0);						 

	# Initialize tag arrays so they are globally avaliable
	foreach my $tag (@TAGS){
	    debugPrint("Creating array named $tag \n");
	    @{$tag};
	}

	# Read source file line by line
	my $linecount = 0;
	while (my $line = <$wf>){
	    $linecount++;
	    # Find any comment line with [tag] - text (any comb of space and #)
	    if ($line =~ /\s*($comment)+\s*\[(\S+)\]\s*-\s*(.+)/) {
			my $fissue = $3;
			my $ftag = $2;
			debugPrint("Issue found!\n");
			debugPrint("Tag: $ftag\n");		
			debugPrint("Issue: $fissue\n");
		
			foreach my $tag (@TAGS) {
		    	if ($ftag eq $tag) {
					# Create hash for each issue found (for each tag)
					my $issue = {};
					$issue->{linenumber} = $linecount;
					$issue->{comment} = $fissue;

					# Create hash for specific issue
					my $digest = md5_hex($issue->{tag}, $issue->{file}, $issue->{comment});
					debugPrint("$digest\n");
					$issue->{md5} = $digest;

					push(@{$tag}, $issue);

					# If Github valid, append file and tag, pass $issue to poster function
					if ($GITHUB_VALID){
						$issue->{file} = $file;
						$issue->{tag} = $tag;
						postGithub($issue);
					}

					# If Bitbucket valid, append file and tag, pass $issue to poster function
					if ($BITBUCKET_VALID){
						$issue->{file} = $file;
						$issue->{tag} = $tag;
						postBitbucket($issue);
					}

		    	}
			}
	    }
	}

	#[fixme] - change name to issueList
	my $issueList = {};
	$issueList->{filename} = "$file";
	
	# Toss on each tag found into the file's hash
	foreach my $tag (@TAGS){
	       	$issueList->{$tag} = [@{$tag}];
		debugPrint(Dumper($issueList));
		undef @{$tag};       		
	}
	return $issueList;
}


###########################################################
# Comment setter
###########################################################

# Determine comment type from file extension
sub getComment {
	my ($file) = @_;
	debugPrint("Getting comment type\n");

	# Grab the ending extension (.something)
	# Check to see whether it is recognized and set comment type
	# If unrecognized, try to grab next .something extension
	# This is to account for file.cpp.1 or file.cpp.bak, ect
	
	while ( (my $ext) = $file =~ m/(\.(\w+))$/){
		# Regex for last extension
		debugPrint("Extension: $ext\n");

		# Determine file type
		# Not using switch/case for compatibility...
		
		# C / C++
		# [todo] - add /* style comment
		if ( $ext eq ".cpp" || $ext eq ".cc" ||  $ext eq ".c" || $ext eq ".h"){
			debugPrint("Comment type is: //\n");
			return "//";
		}
		# Bash / Ruby / Perl	
		elsif ( $ext eq ".sh" || $ext eq ".rb" || $ext eq ".pl"){
			debugPrint("Comment type is: #\n");
			return "#";
		}
		# Can't recognize extension, keep looping
		else {
			$file =~ s/(\.(\w+))$//;
			debugPrint("Didn't recognize, new file: $file\n");
		}
	}
	
	# Didn't find any match, return error (and just use #)
	return 0;
}


###########################################################
# Result Printer Wrapper
###########################################################

# Format the parsed file data and output it nicely
sub createReport {
	# Display output for each file parsed 
	foreach my $entry (@STRUCTURE){
		printResults($entry);
	}
	
	if ($HASLESS){
		system("less -R $TMPOUT");
		close($LESSOUT);
		system("rm $TMPOUT > /dev/null 2>&1");
	}
	return 1;
}


###########################################################
# Individual Result Printer
###########################################################

# Print results from parsing all pretty and stuff
sub printResults {
	my ($entry) = @_;
	# Go through and print info for all files first
	for (my $i = 0; $i < scalar( @{$entry->{files}}); $i++){

		# [fixme] - Same foreach performed below, combine somehow?

		# Go through and see if there are any issues with given file
		# Sets print color and whether to continue to print
		my $issueflag = 0; 
		foreach my $tag (@TAGS){
			if (scalar( @{$entry->{files}[$i]->{$tag}})){
				$issueflag++;
			}
		}
		
		if ($issueflag){
			wprint("\n");
			wprint(BOLD "[ ", RESET);
			wprint(BOLD RED "x ", RESET);
			wprint(BOLD "] ", RESET);
			wprint(UNDERLINE BOLD RED "$entry->{files}[$i]->{filename}", RESET);
		}
		else {
			wprint(BOLD "[ ", RESET);
			wprint(BOLD GREEN "o ", RESET);
			wprint(BOLD "] ", RESET);
			wprint(UNDERLINE BOLD GREEN "$entry->{files}[$i]->{filename}", RESET);
		}

		wprint("\n");
		
		# If there are no issues, don't print anything (go to next file)
		# Else, continue on and print the issues
		($issueflag > 0) ? (1) : (next);	

		# Cycle through all tags and print issues for each	
		foreach my $tag (@TAGS){
		
			# If no issues in tag, don't print	
			if (!scalar( @{$entry->{files}[$i]->{$tag}})){
				next;
			}
		
			# Print tag, line #, and issue	
			wprint(BOLD  "\[ ", RESET);
			wprint(BOLD BLUE "$tag", RESET);
			wprint(BOLD  " \]\n", RESET);

			

			for (my $j = 0; $j < scalar( @{$entry->{files}[$i]->{$tag}}); $j++){
				wprint(WHITE "  line $entry->{files}[$i]->{$tag}[$j]->{linenumber} - ", RESET);
				wprint(BOLD "$entry->{files}[$i]->{$tag}[$j]->{comment} ", RESET);

				# If valid API key
				# Check if issue has been closed on Github or Bitbucket, set to resolved
				if ( ($GITHUB_VALID) ){ 
					if ( ($GITHUB_CLOSED_ISSUES =~ m/$entry->{files}[$i]->{$tag}[$j]->{md5}/) ) {
						wprint(BOLD "\[", RESET);
						wprint(BOLD GREEN "Resolved on GitHub", RESET);
						wprint(BOLD "\]");
					}
				}


				if ( ($BITBUCKET_VALID) ){
					if ( ($BITBUCKET_CLOSED_ISSUES =~ m/$entry->{files}[$i]->{$tag}[$j]->{md5}/) ){
						wprint(BOLD "\[", RESET);
						wprint(BOLD GREEN "Resolved on Bitbucket", RESET);
						wprint(BOLD "\]");
					}
				}

				wprint("\n");
			}
			wprint("\n");
		}
	}

	for (my $i = 0; $i < scalar( @{$entry->{dirs}}); $i++){
		printResults($entry->{dirs}[$i]);
	}
	return 1;
}


###########################################################
# JSON Parser
###########################################################

# Parse JSON response from github/bitbucket issue requests
sub parseJSON {
	my ($json) = @_;

	debugPrint("JSON Parser");

	# Clean up text, separate with : delimiter
	# Throw data into hash
	my $js = {};
	my @lines = split /\n/, $json;
	foreach my $line (@lines){
		my $ind = index($line, ":");
		if ($ind != -1){
			my $field = substr($line, 0, $ind);
			my $value = substr($line, $ind + 1);
			if ($value ne "{" || $value ne "["){
				# Remove trailing spaces, }, ], ,s and all ""
				$field =~ s/^(\s+)}?]?//g;
				$field =~ s/\"?,?//g;

				$value =~ s/^(\s+)\{?\[?//g;
				$value =~ s/\"?,?//g;

				debugPrint("field: $field\n");
				debugPrint("value: $value\n");
				$js->{$field} = $value;
			}
		}
	}
	return $js;
}


###########################################################
# GitHub Setup
###########################################################

# Obtain API key for either Github
sub githubSetup {
	# JSON Response var
	my $js;

	# Set remote setup to one so password isn't asked for in Bitbucket parseConfig section
	# Crappy fix, won't need this when OAuth is implemented for Bitbucket
	$REMOTESETUP = 1;

	# [fixme] - Same code as header just without wprint, make modular
	print(BOLD "------------------------------\n");
	print(BOLD "watson", RESET);
	print(" - ");
	print(BOLD YELLOW "inline issue manager\n", RESET);
	print(BOLD "------------------------------\n\n");

	# [fixme] - Make modular status printer?
	print BOLD "[ ", RESET;
	print BOLD GREEN "+ ", RESET;
	print BOLD "] ", RESET;
	print BOLD "Obtaining OAuth Token for GitHub...\n", RESET;

	# Parse config to make sure no previous API exists
	checkConfig() ? parseConfig() : true;

	if ( ($GITHUB_API  ne "") ||
		 ($GITHUB_REPO ne "") ){
		print BOLD "[ ", RESET;
		print BOLD RED "! ", RESET;
		print BOLD "] ", RESET;
		print BOLD "Previous GitHub API + Repo is in RC, are you sure you want to overwrite?\n", RESET;
		print "      (Y)es/(N)o: ";

		my $overwrite = <STDIN>;
		chomp $overwrite;
		print "\n";
		
		if ($overwrite eq "" || uc($overwrite) eq "NO" ||
			uc($overwrite) eq "N"){
			print BOLD "[ ", RESET;
			print BOLD RED "x ", RESET;
			print BOLD "] ", RESET;
			print BOLD "Not overwriting current GitHub API + repo info\n", RESET;
			cExit(1);
		}
	}
	

	print BOLD "[ ", RESET;
	print BOLD YELLOW "! ", RESET;
	print BOLD "] ", RESET;
	print BOLD "Access to your GitHub account required to make/update issues\n", RESET;
   	
	print "      See help or README for more details on GitHub/Bitbucket access\n\n";	

	# Get username, clear newlines surrounding text
	# If blank, give error
	print BOLD "Username: ", RESET;
	my $username = <STDIN>;
	chomp $username;
	if ($username eq ""){
		print BOLD "[ ", RESET;
		print BOLD RED "x ", RESET;
		print BOLD "] ", RESET;
		print BOLD "Input blank. Please enter your username!\n", RESET;
		cExit(1);
	}

	# cURL to get OAuth Token, returns JSON
	my $call;
	my $response;

	$call = "curl -s -i " .
			"https://api.github.com/authorizations " .
			"-u $username " .
			"-d '{\"scopes\": [\"repo\"], " .
			     "\"note\": \"watson\", " . 
			     "\"note_url\" : \"http://watson.goosecode.com\"}' ";
	print BOLD;
	$response = `$call`;

	print "\n", RESET;
	# [fixme] - Pretty bad way of doing this, either grep or improve parser
	$js = parseJSON($response);
	if ($js->{"Status"} =~ m/201 Created/){
		print BOLD "[ ", RESET;
		print BOLD GREEN "o ", RESET;
		print BOLD "] ", RESET;
		print BOLD "Obtained OAuth Token\n";
	}
	else {
		print BOLD "[ ", RESET;
		print BOLD RED "x ", RESET;
		print BOLD "] ", RESET;
		print BOLD "Unable to obtain OAuth Token\n", RESET;
		#print "      Status: ", $js->{"Status"}, "\n";
		cExit(1);
	}

	print "\n", RESET;

	
	
	# Set API key for use later so we don't have to parse config
	# [reviewme] - Maybe we should just parse config?
	$GITHUB_API = $js->{"token"};
	
	# Get repo information
	# If blank, give error
	print BOLD "[ ", RESET;
	print BOLD YELLOW "! ", RESET;
	print BOLD "] ", RESET;
	print BOLD "Repo information required\n", RESET;
	print "      Please provide owner that repo is under followed by repo name\n";
	print "      e.g. owner: nhmood, repo: watson (case sensitive)\n";
	print "      See help or README for more details on GitHub access\n\n";	

	print BOLD "Owner: ", RESET;
	my $owner = <STDIN>;
	chomp $owner;
	if ($owner eq ""){
		print BOLD "[ ", RESET;
		print BOLD RED "x ", RESET;
		print BOLD "] ", RESET;
		print BOLD "Input blank. Please enter the owner the repo is under!\n", RESET;
		cExit(1);
	}
	print BOLD "Repo: ", RESET;
	my $repo = <STDIN>;
	chomp $repo;
	if ($repo eq ""){
		print BOLD "[ ", RESET;
		print BOLD RED "x ", RESET;
		print BOLD "] ", RESET;
		print BOLD "Input blank. Please enter the repo name!\n", RESET;
		cExit(1);
	}

	my $call = "curl -s -i " .
			   "-H 'Authorization: token $GITHUB_API' " .
			   "https://api.github.com/repos/$owner/$repo/issues";
	my $response = `$call`;
	$js = parseJSON($response);
	print "\n";

	
	if ($js->{"Status"} =~ m/200 OK/){
		print BOLD "[ ", RESET;
		print BOLD GREEN "o ", RESET;
		print BOLD "] ", RESET;
		print BOLD "Repo successfully accessed\n";
	}
	else {
		print BOLD "[ ", RESET;
		print BOLD RED "x ", RESET;
		print BOLD "] ", RESET;
		print BOLD "Unable to access /repo/$owner/$repo\n", RESET;
		#print "      Status: ", $js->{"Status"}, "\n";
		cExit(1);
	}
	print "\n";


	# [fixme] - Make modular status printer?
	print BOLD "[ ", RESET;
	print BOLD GREEN "+ ", RESET;
	print BOLD "] ", RESET;
	print BOLD "Creating label for watson on GitHub...\n", RESET;

	# Create label for watson
	my $call = "curl -s -i " .
		       "-H 'Authorization: token $GITHUB_API' " .
		       "https://api.github.com/repos/$owner/$repo/labels " .
		       "-d '{" .
		       		"\"name\" : \"watson\"," .
		       		"\"color\" : \"00AEEF\" }'";
	my $response = `$call`;
	$js = parseJSON($response);



	if ($js->{"Status"} =~ m/201 Created/){
		print BOLD "[ ", RESET;
		print BOLD GREEN "o ", RESET;
		print BOLD "] ", RESET;
		print BOLD "Label successfully created\n";
	}
	elsif ($js->{"code"} =~ m/already_exists/){
		print BOLD "[ ", RESET;
		print BOLD YELLOW "! ", RESET;
		print BOLD "] ", RESET;
		print BOLD "Label already exists\n";
	}
	else {
		print BOLD "[ ", RESET;
		print BOLD RED "x ", RESET;
		print BOLD "] ", RESET;
		print BOLD "Unable to access /repo/$owner/$repo\n", RESET;
		#print "      Status: ", $js->{"Status"}, "\n";
		cExit(1);
	}
	print "\n";



	# Check if RC exists
	# If it exists, basically replicate it and remove [github/bitbucket tag]
	my $nlc = 0;

	if (checkConfig()){
		debugPrint("Config exists, copying\n");
		open(my $in, "<", "$RCNAME");
		open(my $out, ">", "$RCNAME.new");
		my $section = "";
		while (my $line = <$in>){
			debugPrint("$line\n");
			# Regex for section
			if ($line =~ /^\[(\w+)\]/){
			    $section = $1;
			}
		
						
			# Check for newlines
			# If we already have 2 newlines before any actual content, skip
			# This is just to make the RC file output nicer looking
			if ($line eq "\n"){
				debugPrint("Newline found\n");
				if (++$nlc < 3){
					debugPrint("Less than 3 newlines so far, let it print\n");
					print $out $line;
				}
			}
			# If not in Github section, safe to copy
			# make $remotestr lowercase and check that + repo 
			elsif ($section ne (lc("github")) &&
				   $section ne (lc("githubrepo"))){
				
				debugPrint("Not in git section, copying to new rc\n");
				print $out $line;
				# Reset newline count
				$nlc = 0;
			}

			debugPrint("line: $line");
			debugPrint("nlc: $nlc\n");


		}

		# Remove old RC file and replace with new one
		system("rm $RCNAME > /dev/null 2>&1");
		system("cp $RCNAME.new $RCNAME > /dev/null 2>&1");	
		system("rm $RCNAME.new > /dev/null 2>&1");
	}

	# Append API token to end of file (old or new, doesn't matter now)
	open(my $file, "+>>", "$RCNAME");
	
	# Make sure there are only 2 newlines between items in RC
	for ($i = $nlc; $i < 2; $i++){
		print $file "\n";
	}
	print $file "[github]\n";
	print $file ($GITHUB_API);
	print $file "\n\n\n";
	print $file "[githubrepo]\n";
	print $file "$owner/$repo";
	print $file "\n";
	close($file);



	print BOLD "[ ", RESET;
	print BOLD GREEN "o ", RESET;
	print BOLD "] ", RESET;
	print BOLD "GitHub successfully setup\n", RESET;
	print "      Issues will now automatically be updated on GitHub by default\n";
	#print "      Use -l, --local to not update against GitHub\n";
	print "      See help or README for more details on GitHub/Bitbucket access\n";	
	print "\n";
	cExit(0);
}


###########################################################
# Github Issue Getter
###########################################################

# Post issues to github/bitbucket 
sub getGithubIssues {
	# Only attempt if API is specified
	if (length($GITHUB_API) != 0){
		debugPrint("Getting GitHub Issues\n");
		# Get open tickets
		my $call = "curl -s -i " .
				   "-H 'Authorization: token $GITHUB_API' " .
				   "https://api.github.com/repos/$GITHUB_REPO/issues?labels\\=watson\\&state\\=open";
		$GITHUB_OPEN_ISSUES = `$call`;
		debugPrint($GITHUB_OPEN_ISSUES);

		# Check or a Status 200 OK, if not, API key might be invalid, warn user
		# Set GITHUB_VALID to 0 so that no remote related calls will be made
		if ($GITHUB_OPEN_ISSUES !~ m/200 OK/){
			$GITHUB_VALID = 0;
			wprint(BOLD "[ ", RESET);
			wprint(BOLD RED "x ", RESET);
			wprint(BOLD "] ", RESET);
			wprint("--> ", RESET);
			wprint(BOLD "Unable to access remote, GitHub API may be invalid\n");
			wprint(BOLD "          Consider running --remote (-r) option to regenerate key\n\n", RESET);
		}
		# Else get the closed tickets also and set GITHUB_VALID to 1
		else {
			$GITHUB_VALID = 1;
			$call = "curl -s -i " .
					"-H 'Authorization: token $GITHUB_API' " .
					"https://api.github.com/repos/$GITHUB_REPO/issues?labels\\=watson\\&state\\=closed"; 
			$GITHUB_CLOSED_ISSUES = `$call`;
			debugPrint($GITHUB_CLOSED_ISSUES);
		}
	}
	else {
		debugPrint("No GitHub API, ignoring issue list\n");
	}

}


###########################################################
# Github Issue Poster
###########################################################

# Post issues to github/bitbucket 
sub postGithub {
	my ($issue) = @_;
	# Github API has been registered, post on Github
	if (length($GITHUB_API) != 0){
		
		# Check if md5 of issue has already been posted
		# [fixme] - if issue with same name in same file is made, won't ever get posted again :-/
		if ($GITHUB_OPEN_ISSUES !~ m/$issue->{md5}/ && $GITHUB_CLOSED_ISSUES !~ m/$issue->{md5}/){
			# Format title and body for creating issue
			# Title format: comment [basename of file], escape any '
			my $title = $issue->{file};
			$title =~ s/^(.+)\///;
			$title = "$issue->{comment} [" . $title . "]";
			# [fixme] - Figure out how to escape ' character on JSON post
			$title =~ s/\'//;

			
			debugPrint("Formatted title for GitHub Post : $title\n");

			# Format comment to escape any ' so JSON will be formatted properly
			my $body = "__filename__ : $issue->{file}\\n" .
					   "__line #__ : $issue->{linenumber}\\n" .
					   "__tag__ : $issue->{tag}\\n" .
					   "__md5__ : $issue->{md5}\\n";
			debugPrint("Formatted body for GitHub Post : $body\n");

			my $call = "curl -s -i " .
					   "-H 'Authorization: token $GITHUB_API' " .
					   "https://api.github.com/repos/$GITHUB_REPO/issues " .
					   "-d '{\"title\" : \"$title\", " .
					   "\"body\" : \"$body\", " .
					   "\"labels\" : [ \"watson\", \"$issue->{tag}\"]}'";
			debugPrint("Formatted call for GitHub Post : $call\n");
			my $response = `$call`;
			debugPrint($response);
		}
	}

	if (length($BITBUCKET_API) != 0){
		# Bitbucket Implementation
	}


}


###########################################################
# Bitbucket Setup
###########################################################

# Set up Bitbucket access
# [todo] - Only basic http auth, get OAuth for Bitbucket
# Bitbucket OAuth needs to redirect to some grant access page
# Not sure how to do that with a CLI, basic HTTP auth for now
sub bitbucketSetup {
	# JSON Response var
	my $js;

	# Set remote setup to one so password isn't asked for in Bitbucket parseConfig section
	# Crappy fix, won't need this when OAuth is implemented for Bitbucket
	$REMOTESETUP = 1;

	# [fixme] - Same code as header just without wprint, make modular
	print(BOLD "------------------------------\n");
	print(BOLD "watson", RESET);
	print(" - ");
	print(BOLD YELLOW "inline issue manager\n", RESET);
	print(BOLD "------------------------------\n\n");

	# [fixme] - Make modular status printer?
	print BOLD "[ ", RESET;
	print BOLD GREEN "+ ", RESET;
	print BOLD "] ", RESET;
	print BOLD "Attempting to access Bitbucket...\n", RESET;;

	# Parse config to make sure no previous API exists
	checkConfig() ? parseConfig() : true;

	if ( ($BITBUCKET_API  ne "") ||
	     ($BITBUCKET_REPO ne "") ){
		print BOLD "[ ", RESET;
		print BOLD RED "! ", RESET;
		print BOLD "] ", RESET;
		print BOLD "Previous Bitbucket Repo is in RC, are you sure you want to overwrite?\n", RESET;
		print "      (Y)es/(N)o: ";

		my $overwrite = <STDIN>;
		chomp $overwrite;
		print "\n";
		
		if ($overwrite eq "" || uc($overwrite) eq "NO" ||
			uc($overwrite) eq "N"){
			print BOLD "[ ", RESET;
			print BOLD RED "x ", RESET;
			print BOLD "] ", RESET;
			print BOLD "Not overwriting current Bitbucket repo info\n", RESET;
			cExit(1);
		}
	}
	

	print BOLD "[ ", RESET;
	print BOLD YELLOW "! ", RESET;
	print BOLD "] ", RESET;
	print BOLD "Access to your Bitbucket account required to make/update issues\n", RESET;
   	
	print "      See help or README for more details on GitHub/Bitbucket access\n\n";

	print BOLD "[ ";
	print BOLD RED "! ", RESET;
	print BOLD "]", RESET;
	print BOLD " Bitbucket OAuth not implemented yet.\n", RESET;
	print "      Basic HTTP Auth in use, will request PW entry every time.\n\n";


	# Get username, clear newlines surrounding text
	# If blank, give error
	print BOLD "Username: ", RESET;
	my $username = <STDIN>;
	chomp $username;
	if ($username eq ""){
		print BOLD "[ ", RESET;
		print BOLD RED "x ", RESET;
		print BOLD "] ", RESET;
		print BOLD "Input blank. Please enter your username!\n", RESET;
		cExit(1);
	}

	print "\n";
	# cURL to get OAuth Token, returns JSON
	

	# Get repo information
	# If blank, give error
	print BOLD "[ ", RESET;
	print BOLD YELLOW "! ", RESET;
	print BOLD "] ", RESET;
	print BOLD "Repo information required\n", RESET;
	print "      Please provide owner that repo is under followed by repo name\n";
	print "      e.g. owner: nhmood, repo: watson (case sensitive)\n";
	print "      See help or README for more details on GitHub access\n\n";	

	
	print BOLD "Owner: ", RESET;
	my $owner = <STDIN>;
	chomp $owner;
	if ($owner eq ""){
		print BOLD "[ ", RESET;
		print BOLD RED "x ", RESET;
		print BOLD "] ", RESET;
		print BOLD "Input blank. Please enter the owner the repo is under!\n", RESET;
		cExit(1);
	}
	print BOLD "Repo: ", RESET;
	my $repo = <STDIN>;
	chomp $repo;
	if ($repo eq ""){
		print BOLD "[ ", RESET;
		print BOLD RED "x ", RESET;
		print BOLD "] ", RESET;
		print BOLD "Input blank. Please enter the repo name!\n", RESET;
		cExit(1);
	}

	print "\n";

	my $call;
	my $response;

    #bit bucket lowercases repo name. BobSmithRepo = bobsmithrepo
    my $lcrepo = lc($repo);
	$call = "curl -s -i " .
			"https://bitbucket.org/api/1.0/repositories/$owner/$lcrepo " .
			"-u $username";
	print BOLD;
	$response = `$call`;
	print "\n", RESET;
	# [fixme] - Pretty bad way of doing this, either grep or improve parser
	if ($response =~ m/HTTP\/1.1 200 OK/){
		print BOLD "[ ", RESET;
		print BOLD GREEN "o ", RESET;
		print BOLD "] ", RESET;
		print BOLD "Successfully accessed remote repo with given credentials\n";
	}
	else {
		print BOLD "[ ", RESET;
		print BOLD RED "x ", RESET;
		print BOLD "] ", RESET;
		print BOLD "Unable to access remote repo with given credentials\n", RESET;
		print BOLD "Check that credentials are correct and repository exists under owner\n", RESET;
		#print "      Status: ", $js->{"Status"}, "\n";
		cExit(1);
	}

	print "\n", RESET;

	
	
	# Check if RC exists
	# If it exists, basically replicate it and remove [github/bitbucket tag]
	if (checkConfig()){
		debugPrint("Config exists, copying\n");
		open(my $in, "<", "$RCNAME");
		open(my $out, ">", "$RCNAME.new");
		my $section = "";
		my $nlc = 0;
		while (my $line = <$in>){
			debugPrint("$line\n");
			# Regex for section
			if ($line =~ /^\[(\w+)\]/){
			    $section = $1;
			}
		
						
			# Check for newlines
			# If we already have 2 newlines before any actual content, skip
			# This is just to make the RC file output nicer looking
			if ($line eq "\n"){
				debugPrint("Newline found\n");
				if (++$nlc < 3){
					debugPrint("Less than 3 newlines so far, let it print\n");
					print $out $line;
				}
			}
			# If not in bitbucket or github section, safe to copy
			# make $remotestr lowercase and check that + repo 
			elsif ( $section ne (lc("bitbucket"))  &&
				    $section ne (lc("bitbucketrepo")) ){

			
				debugPrint("Not in bitbucket section, copying to new rc\n");
				print $out $line;
				# Reset newline count
				$nlc = 0;
			}

			debugPrint("line: $line");
			debugPrint("nlc: $nlc\n");


		}

		# Remove old RC file and replace with new one
		system("rm $RCNAME > /dev/null 2>&1");
		system("cp $RCNAME.new $RCNAME > /dev/null 2>&1");	
		system("rm $RCNAME.new > /dev/null 2>&1");
	}

	# Append API token to end of file (old or new, doesn't matter now)
	open(my $file, "+>>", "$RCNAME");
	
	# Make sure there are only 2 newlines between items in RC
	for ($i = $nlc; $i < 2; $i++){
		print $file "\n";
	}
	# Store username in bitbucket api section since we don't OAuth yet
	print $file "[bitbucket]\n";
	print $file "$username\n";
	print $file "\n\n";
	print $file "[bitbucketrepo]\n";
	print $file "$owner/$repo";
	print $file "\n";
	close($file);

	print BOLD "[ ", RESET;
	print BOLD GREEN "o ", RESET;
	print BOLD "] ", RESET;
	print BOLD "Bitbucket successfully setup\n", RESET;
	print "      Issues will now automatically be updated on Bitbucket by default\n";
	print "      Use -l, --local to not update against GitHub\n";
	print "      See help or README for more details on GitHub/Bitbucket access\n";	
	print "\n";
	cExit(0);
}


###########################################################
# Bitbucket Issue Getter
###########################################################

# Post issues to github/bitbucket 
sub getBitbucketIssues {
	# Only attempt if repo is specified
	if (length($BITBUCKET_REPO) != 0){
		debugPrint("Getting Bitbucket Issues\n");

		print BOLD "Bitbucket password required for remote checking/posting: ", RESET;
		system("stty -echo");
		my $pw = <STDIN>;
		chomp $pw;
		system("stty echo");
		print "\n";
		if ($pw eq ""){
			print BOLD "[ ", RESET;
			print BOLD RED "x ", RESET;
			print BOLD "] ", RESET;
			print BOLD "Input blank. Will not check/update against Bitbucket\n", RESET;
			$BITBUCKET_PW = "";
			$BITBUCKET_VALID = 0;
			return 1;
		}
		else {
			$BITBUCKET_PW = $pw;
		}

		# Get all issues, Bitbucket differentiates between open/new so we can just look for all
		# The open issue var is used only for preventing posting again anyways
		# Only need closed ones to update final output, might change in Github too? 
		my $call = "curl -s -i " .
				   "https://bitbucket.org/api/1.0/repositories/$BITBUCKET_REPO/issues " .
				   "-u $BITBUCKET_API:$pw";
		$BITBUCKET_OPEN_ISSUES = `$call`;
		debugPrint($BITBUCKET_OPEN_ISSUES);
		
		# Check for a Status 
		if ($BITBUCKET_OPEN_ISSUES !~ m/HTTP\/1.1 200 OK/){
			$BITBUCKET_VALID = 0;
			wprint(BOLD "[ ", RESET);
			wprint(BOLD RED "x ", RESET);
			wprint(BOLD "] ", RESET);
			wprint("--> ", RESET);
			wprint(BOLD "Unable to access remote, Bitbucket settings may be invalid\n");
			wprint(BOLD "          Consider running --remote (-r) option to regenerate settings\n\n", RESET);
		}
		# Else get the closed tickets also and set BITBUCKET_VALID to 1
		else {
			$BITBUCKET_VALID = 1;
			$call = "curl -s -i " .
					"https://bitbucket.org/api/1.0/repositories/$BITBUCKET_REPO/issues?status\\=resolved " .
					"-u $BITBUCKET_API:$pw";

			$BITBUCKET_CLOSED_ISSUES = `$call`;
			debugPrint($BITBUCKET_CLOSED_ISSUES);
		}
	}
	else {
		debugPrint("No Bitbucket Repo, ignoring issue list\n");
	}
}


###########################################################
# Bitbucket Issue Poster
###########################################################

# Post issues to github/bitbucket 
sub postBitbucket {
	my ($issue) = @_;
	# Bitbucket API has been registered, post on Github
	if (length($BITBUCKET_API) != 0){
		# Check if md5 of issue has already been posted
		# [fixme] - if issue with same name in same file is made, won't ever get posted again :-/
		if ($BITBUCKET_OPEN_ISSUES !~ m/$issue->{md5}/ && $BITBUCKET_CLOSED_ISSUES !~ m/$issue->{md5}/){
			# Format title and body for creating issue
			# Title format: comment [basename of file], escape any '
			my $title = $issue->{file};
			$title =~ s/^(.+)\///;
			$title = "$issue->{comment} [" . $title . "]";
			# [fixme] - Figure out how to escape ' character on JSON post
			# Remove ' for now
			$title =~ s/\'//;
			# Since not JSON, need to replace spaces with +
			$title =~ s/\s/\+/g;
			
			debugPrint("Formatted title for Bitbucket Post : $title\n");

			# %0D%0A at end so newlines will show up properly on Bitbucket
			my $body = "__filename__ : $issue->{file}%0D%0A%0D%0A  " .
					   "__line #__ : $issue->{linenumber}%0D%0A%0D%0A  " .
					   "__tag__ : $issue->{tag}%0D%0A%0D%0A  " .
					   "__md5__ : $issue->{md5}%0D%0A%0D%0A  ";
			debugPrint("Formatted body for Bitbucket Post : $body\n");
			# Replace spaces with + like above
			$body =~ s/\s/\+/g;

			# Format call, pass all params as -d to avoid \= \&
			my $call = "curl -s -i " .
					   "https://bitbucket.org/api/1.0/repositories/$BITBUCKET_REPO/issues " .
					   "-d 'title=$title&" .
					   "content=$body' " .
					   "-u $BITBUCKET_API:$BITBUCKET_PW";
			# If you allow this to print below pw will show up as plain text!
			debugPrint("Formatted call for Bitbucket Post : $call\n");
			my $response = `$call`;
			debugPrint($response);
		}
	}
}
